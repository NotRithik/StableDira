Directory: stable-dira

Directory Structure:
```
.
├── .gitignore
├── Cargo.toml
├── LICENSE
├── README.md
├── generate_message_ts.sh
├── optimize.sh
│   │   ├── quint/lib/BoundedUInt.qnt
│   │   ├── quint/lib/bank.qnt
│   │   ├── quint/lib/basicSpells.qnt
│   │   ├── quint/lib/cw_types.qnt
│   │   ├── quint/lib/cw_utils.qnt
│   │   └── quint/lib/messaging.qnt
│   └── quint/stable_dira_stubs.qnt
│   ├── src/contract.rs
│   ├── src/error.rs
│   ├── src/lib.rs
│   ├── src/msg.rs
│   ├── src/schema.rs
│   └── src/state.rs
    └── tests/integration.rs
```

Contents of Cargo.toml:
```
[package]
name = "stable-dira"
version = "0.1.0"
authors = ["Rithik Kumar S <rithikum123@gmail.com>"]
edition = "2018"

exclude = [
  # Those files are rust-optimizer artifacts. You might want to commit them for convenience but they should not be part of the source code publication.
  "contract.wasm",
  "hash.txt",
]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[profile.release]
opt-level = 3
debug = false
rpath = false
lto = true
debug-assertions = false
codegen-units = 1
panic = 'abort'
incremental = false
overflow-checks = true

[features]
# for more explicit tests, cargo test --features=backtraces
# backtraces = ["cosmwasm-std/backtraces"]
# use library feature to disable all instantiate/execute/query exports
library = []

[dependencies]
cosmwasm-std = "2.1.5"
cw-storage-plus = "2.0.0"
cw2 = "2.0.0"
cw20 = "2.0.0"
cw20-base = "2.0.0"
schemars = "0.8"
serde = { version = "1.0", default-features = false, features = ["derive"] }
serde-json-wasm = "1.0.1"
serde_json = "1.0.133"
thiserror = { version = "2.0" }
cosmwasm-schema = { version = "2.1.5" }
bech32 = "0.11.0"

[dev-dependencies]
# STUFF BELOW IS REQUIRED ONLY FOR TEST BUILDS
cw-multi-test = "2.2.0"
cw-utils = "2.0.0"

[[bin]]
name = "schema"
path = "src/schema.rs"


```

Contents of LICENSE:
```
MIT License

Copyright (c) 2024 Rithik Kumar S and Contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

Contents of README.md:
```
# Dira: The Decentralized AED Stablecoin - Smart Contract Repository

This repository houses the **smart contract** for **Dira**, a decentralized, overcollateralized stablecoin pegged to the Emirati Dirham (AED). Built using CosmWasm in Rust and designed for the Cosmos ecosystem, Dira provides a robust and transparent smart contract to facilitate the minting of a digital AED currency, backed by the OM token.

Dira's smart contract is the core of the Dira protocol, ensuring the stability, security, and decentralized nature of the AED stablecoin.  A user-friendly frontend application is also available (see below) to interact with this smart contract once deployed.

---
 
## Table of Contents
- [Overview](#overview)
- [Features](#features)
- [Getting Started - Smart Contract Development](#getting-started---smart-contract-development)
- [Smart Contract Architecture](#smart-contract-architecture)
- [Frontend Application](#frontend-application)
- [How Dira Works - Smart Contract Logic](#how-dira-works---smart-contract-logic)
- [Schema Generation](#schema-generation)
- [Roadmap](#roadmap)
- [Contributing](#contributing)
- [License](#license)

---

## Overview

Dira addresses the growing demand for localized stablecoins within the Cosmos ecosystem, particularly in regions like Dubai where tokenized real-world assets (RWAs) are gaining traction. This smart contract implements the core logic for Dira, providing a reliable and decentralized AED-pegged stablecoin solution, with OM tokens serving as collateral.

Dira is designed to leverage Inter-Blockchain Communication (IBC) for seamless integration with other Cosmos chains, enhancing liquidity for the AED stablecoin.  Liquidity pools for AED and other stablecoins are envisioned to facilitate efficient on-chain currency exchange.  Furthermore, Dira aims to drive utility and demand for the OM token through its protocol mechanisms.

---

## Features

The Dira smart contract incorporates the following key features:

*   **Decentralized and Overcollateralized:** Dira stablecoins are fully backed by OM collateral, algorithmically ensuring stability and security through smart contract logic.
*   **Cross-Chain Compatibility:**  Designed for future integration with Noble, Mantra, and other Cosmos chains via IBC, enabling broader accessibility and utility.
*   **Enables Liquidity Pools:**  Provides the foundation for the creation of AED/USD and other stablecoin liquidity pools, facilitating efficient on-chain foreign exchange.
*   **Transparent Governance (Administered):**  Admin functionalities within the smart contract are designed to be executed by approved wallet addresses, ensuring transparent and controlled administrative actions.
*   **Robust State Management:**  Secure on-chain storage of critical state variables, including collateral amounts, minted stablecoins, and authorized admin addresses.
*   **Liquidation Mechanism:**  Implements automated liquidation processes to maintain collateral health and protocol solvency when collateral ratios fall below predefined thresholds.
*   **Public Query Endpoints:** Offers comprehensive public query endpoints for transparent access to all contract states, including collateral levels, minted Dira supply, and collateral price information.

---

## Getting Started - Smart Contract Development

To begin development or contribute to the Dira smart contract, follow these steps:

1.  **Clone the Smart Contract Repository**
    ```bash
    git clone https://github.com/NotRithik/StableDira.git
    cd StableDira
    ```

2.  **Compile the Smart Contract**
    Ensure you have [Rust](https://www.rust-lang.org/) installed and the `wasm32-unknown-unknown` target added to your Rust toolchain.
    ```bash
    rustup target add wasm32-unknown-unknown
    cargo build --target wasm32-unknown-unknown --release
    ```
    For optimized production builds, you can utilize the Cosmos optimizer Docker image:
    ```bash
    docker run --rm -v "$(pwd)":/code --mount type=volume,source="$(basename "$(pwd)")_cache",target=/target --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry cosmwasm/optimizer:0.16.0
    ```

3.  **Run Unit Tests**
    Utilize `cw-multi-test` for comprehensive unit testing of the smart contract logic.
    ```bash
    cargo test -- --show-output
    ```

4.  **Deploy the Smart Contract**
    The compiled `.wasm` file (located in the `target/wasm32-unknown-unknown/release/` directory) can be deployed to a compatible Cosmos chain, such as Mantra Chain's DuKong testnet.  Deployment requires appropriate chain tooling and configuration.

---

## Smart Contract Architecture

The Dira smart contract, written in Rust using CosmWasm, is structured to ensure security, transparency, and efficiency.

-   **State Management:** The contract meticulously manages its state on-chain, ensuring secure storage and retrieval of:
    *   Collateral amounts locked by users.
    *   The total supply of minted Dira stablecoins.
    *   A list of authorized admin addresses with privileged functionalities.
    *   Key protocol parameters such as liquidation and minting health thresholds.

-   **Query Functions:**  Transparency is paramount. The contract exposes a suite of public query functions, enabling anyone to retrieve critical contract state information, including:
    *   User-specific locked collateral amounts.
    *   User-specific minted Dira balances.
    *   Current collateral price as determined by the price oracle.
    *   Protocol-wide liquidation and minting health parameters.
    *   The list of authorized admin addresses.
    *   The denomination of the collateral token.
    *   The contract address of the CW20 Dira token.

The source code for the Dira Smart Contract is available in this repository: [Dira Smart Contract Repository](https://github.com/NotRithik/StableDira).

---

## Frontend Application

A user-friendly web interface, the **Dira Frontend**, has been developed to facilitate interaction with the deployed Dira smart contract on the Mantra DuKong testnet.

The frontend currently implements the following core functionalities:

*   **Lock Collateral:**  Allows users to lock OM tokens within the smart contract to mint Dira stablecoins.
*   **Mint/Return Dira:** Provides an intuitive interface for users to mint Dira against their collateral and return Dira to unlock their OM.
*   **Dashboard:**  Offers users a comprehensive dashboard to monitor their wallet connection status, account information, and relevant market data.

Future frontend enhancements are planned, including features such as collateral auctions, oracle price feed visualization, and governance participation interfaces.

Live Preview of the Dira Frontend: [Dira Frontend](https://dira-alpha.vercel.app/).
Frontend Source Code Repository: [Dira Frontend Repository](https://github.com/NotRithik/dira-frontend)

---

## How Dira Works - Smart Contract Logic

The Dira smart contract operates through the following core mechanisms:

1.  **Collateral Locking:**
    Users initiate the process by locking OM tokens within the smart contract as collateral. This collateral acts as backing for the Dira stablecoins they intend to mint.

2.  **Stablecoin Minting:**
    Upon locking collateral, the smart contract calculates the user's current collateral health ratio based on the prevailing collateral price.  Users are then permitted to mint Dira stablecoins proportionally to their locked collateral, ensuring overcollateralization.

3.  **Stablecoin Burning (Returning):**
    To unlock their OM collateral, users must return (burn) an equivalent amount of Dira stablecoins to the smart contract. This burn mechanism maintains the peg and overall supply of Dira.

4.  **Liquidation Protocol:**
    The smart contract incorporates a robust liquidation protocol to safeguard the system's solvency. If a user's collateral health ratio declines below a predefined liquidation threshold (due to fluctuations in collateral price), their collateral becomes eligible for liquidation. Other users can then liquidate undercollateralized positions, receiving a portion of the liquidated collateral as a reward, while ensuring the system remains solvent.

---

## Schema Generation

To ensure type consistency and message integrity between the smart contract and external interfaces (such as the frontend), this project includes a schema generation script.

Execute the `generate_message_ts.sh` script to automatically generate TypeScript schema files for all smart contract messages and query responses:

```bash
./scripts/generate_message_ts.sh
```

---

## Roadmap

The Dira project follows a phased roadmap for development and expansion:

*   **Phase 1: Testnet Deployment and Core Functionality**
    *   Successful deployment of the Dira smart contract on a testnet environment (Mantra DuKong).
    *   Development and deployment of a user-friendly web interface (Dira Frontend).
    *   Comprehensive security audits of the smart contract codebase.

*   **Phase 2: Cross-Chain Integration and Liquidity Enhancement**
    *   Implementation of Inter-Blockchain Communication (IBC) to enable Dira's integration with Noble, Mantra, and potentially other Cosmos-based chains.
    *   Establishment of liquidity pools for AED/USD stablecoins to facilitate on-chain currency exchange and increase Dira's utility.

*   **Phase 3: Regional Expansion and Advanced Features**
    *   Expansion of Dira to support additional regional stablecoins beyond AED, such as the Singapore Dollar (SGD).
    *   Development of UI components for a multi-currency stablecoin Decentralized Exchange (DEX) interface.
    *   Implementation of on-chain governance mechanisms for the Dira protocol, potentially including governance token integration.

---

## Contributing

We welcome contributions to the Dira smart contract project.

1.  Fork this repository: [Dira Smart Contract Repository](https://github.com/NotRithik/StableDira).
2.  Create a dedicated feature branch for your proposed changes.
3.  Submit a pull request with a clear and detailed description of your contributions.

For substantial changes or feature additions, it is recommended to open an issue first to discuss your ideas and approach with the project maintainers.

---

## License

The Dira smart contract project is licensed under the [MIT License](LICENSE).  See the [LICENSE](LICENSE) file for full license details.

---

**Dira Smart Contract - The foundation for a decentralized and stable Emirati Dirham currency within the Cosmos ecosystem.**

```

Contents of optimize.sh:
```
#!/bin/bash
docker run --rm -v "$(pwd)":/code \
  --mount type=volume,source="$(basename "$(pwd)")_cache",target=/target \
  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \
  cosmwasm/optimizer:0.16.0

```

Contents of generate_message_ts.sh:
```
#!/bin/bash

# Generate schema
cargo run --bin schema

# Clear previous message_types ts files
rm -rf message_types

# Ensure output directory exists
mkdir -p message_types

# Function to convert snake_case to PascalCase
to_pascal_case() {
    # Split the string by underscore and store in array
    IFS='_' read -ra words <<< "$1"
    
    # Initialize an empty result string
    result=""

    # Loop through each word, capitalize the first letter, and append
    for word in "${words[@]}"; do
        # Use `awk` to capitalize the first letter if `${word^}` doesn't work
        result+=$(echo "${word}" | awk '{print toupper(substr($0,1,1)) tolower(substr($0,2))}')
    done
    
    echo "$result"
}

# Process each matching JSON file in the schema directory
for file in schema/*_msg.json; do
  # Extract the base filename without path or extension
  base_name=$(basename "$file" .json)
  
  # # Convert to PascalCase and add "Types.ts" suffix
  # pascal_case_name=$(to_pascal_case "$base_name")Types.ts

  # Convert to PascalCase
  pascal_case_name=$(to_pascal_case "$base_name").ts
  
  
  # Run json2ts command
  npx json2ts -i "$file" -o "message_types/$pascal_case_name"
  
  # Check for success
  if [ $? -eq 0 ]; then
    echo "Successfully processed $file -> message_types/$pascal_case_name"
  else
    echo "Error processing $file"
  fi
done
```

Contents of tests/integration.rs:
```
use cosmwasm_std::{coins, Addr, Decimal, Uint128};
use cw20::MinterResponse;
use cw20_base::msg::{ExecuteMsg as Cw20ExecuteMsg, InstantiateMsg as Cw20InstantiateMsg};
use cw_multi_test::{App, AppBuilder, Contract, ContractWrapper, Executor};
use stable_dira::msg::{
    AdminAddressesResponse, CW20DiraContractAddressResponse, CollateralPriceResponse,
    CollateralResponse, CollateralTokenDenomResponse, ExecuteMsg as DiraExecuteMsg,
    InstantiateMsg as DiraInstantiateMsg, LiquidationHealthResponse, MintableHealthResponse,
    MintedDiraResponse, QueryMsg as StableDiraQueryMsg, StablecoinHealthResponse,
};

// Mock implementation for Dira stablecoin contract
fn dira_contract() -> Box<dyn Contract<cosmwasm_std::Empty>> {
    let contract = ContractWrapper::new(
        stable_dira::contract::execute,
        stable_dira::contract::instantiate,
        stable_dira::contract::query,
    );
    Box::new(contract)
}

// Mock implementation for CW20 base contract
fn cw20_contract() -> Box<dyn Contract<cosmwasm_std::Empty>> {
    let contract = ContractWrapper::new(
        cw20_base::contract::execute,
        cw20_base::contract::instantiate,
        cw20_base::contract::query,
    );
    Box::new(contract)
}

// Generate Bech32 Address:
// dbg!(bech32::encode::<bech32::Bech32>(
//     bech32::Hrp::parse("cosmwasm").unwrap(),
//     &[
//         0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x10, 0x11, 0x12, 0x13, 0x14,
//         0x15, 0x16, 0x17, 0x18, 0x12, 0x20
//     ]
// )
// .unwrap());

// Helper to initialize the app and deploy both contracts
fn setup_app() -> (App, Addr, Addr, Addr, Addr) {
    let mut app = AppBuilder::new().build(|router, _, storage| {
        // Initialize app state with some balances
        router
            .bank
            .init_balance(
                storage,
                &Addr::unchecked("cosmwasm1qypqxpq9qcrsszgszyfpx9q4zct3sxfqx5vwjh"),
                coins(100_000_000_000_000u128, "uatom"),
            )
            .unwrap();

        router
            .bank
            .init_balance(
                storage,
                &Addr::unchecked("cosmwasm1qypqxpq9qcrsszgszyfpx9q4zct3sy3q8mmchv"),
                coins(100_000_000_000_000u128, "uatom"),
            )
            .unwrap();
    });

    // Store the CW20 base contract code
    let cw20_code_id = app.store_code(cw20_contract());

    // Instantiate the CW20 token contract
    let cw20_contract_addr = app
        .instantiate_contract(
            cw20_code_id,
            Addr::unchecked("cosmwasm1qypqxpq9qcrsszgszyfpx9q4zct3sxfqx5vwjh"), // Admin address
            &Cw20InstantiateMsg {
                name: "Dira".to_string(),
                symbol: "DIRA".to_string(),
                decimals: 6,
                initial_balances: vec![],
                mint: Some(MinterResponse {
                    minter: "cosmwasm1qypqxpq9qcrsszgszyfpx9q4zct3sxfqx5vwjh".to_string(),
                    cap: None,
                }),
                marketing: None,
            },
            &[],
            "CW20 Dira Token",
            None,
        )
        .unwrap();

    // Store the Dira stablecoin contract code
    let dira_code_id = app.store_code(dira_contract());

    // Instantiate the Dira stablecoin contract
    let dira_contract_addr = app
        .instantiate_contract(
            dira_code_id,
            Addr::unchecked("cosmwasm1qypqxpq9qcrsszgszyfpx9q4zct3sxfqx5vwjh"), // Admin address
            &DiraInstantiateMsg {
                liquidation_health: Decimal::from_ratio(110u128, 100u128),
                mintable_health: Decimal::from_ratio(130u128, 100u128),
                collateral_token_denom: "uatom".to_string(),
                cw20_dira_contract_address: Some(cw20_contract_addr.clone()),
            },
            &[],
            "Dira Stablecoin",
            None,
        )
        .unwrap();

    // Update the CW20 token's minter to the Dira contract
    let update_minter_msg = Cw20ExecuteMsg::UpdateMinter {
        new_minter: Some(dira_contract_addr.to_string()),
    };
    let res = app.execute_contract(
        Addr::unchecked("cosmwasm1qypqxpq9qcrsszgszyfpx9q4zct3sxfqx5vwjh"),
        cw20_contract_addr.clone(),
        &update_minter_msg,
        &[],
    );
    assert!(res.is_ok());
    dbg!("Updated CW20 token minter to Dira contract");

    // Return the app instance, both contract addresses, and user addresses
    (
        app,
        dira_contract_addr,
        cw20_contract_addr,
        Addr::unchecked("cosmwasm1qypqxpq9qcrsszgszyfpx9q4zct3sxfqx5vwjh"), // Admin
        Addr::unchecked("cosmwasm1qypqxpq9qcrsszgszyfpx9q4zct3sy3q8mmchv"), // Non-admin
    )
}

#[test]
fn test_setup_instance() {
    let (_app, dira_contract_addr, cw20_contract_addr, _admin, _non_admin) = setup_app();
    assert!(!dira_contract_addr.to_string().is_empty());
    assert!(!cw20_contract_addr.to_string().is_empty());
    dbg!("Successfully instantiated both contracts!");
}

#[test]
fn test_admin_functions() {
    let (mut app, dira_contract_addr, _cw20_contract_addr, admin, non_admin) = setup_app();

    // Test setting collateral price
    let msg = DiraExecuteMsg::SetCollateralPriceInDirham {
        collateral_price_in_dirham: Decimal::from_ratio(3309u128, 100u128),
    };
    let res = app.execute_contract(admin.clone(), dira_contract_addr.clone(), &msg, &[]);
    assert!(res.is_ok());

    let res = app.execute_contract(non_admin.clone(), dira_contract_addr.clone(), &msg, &[]);
    assert!(res.is_err());

    // Test setting mintable health
    let msg = DiraExecuteMsg::SetMintableHealth {
        mintable_health: Decimal::percent(195),
    };
    let res = app.execute_contract(admin.clone(), dira_contract_addr.clone(), &msg, &[]);
    assert!(res.is_ok());

    let res = app.execute_contract(non_admin.clone(), dira_contract_addr.clone(), &msg, &[]);
    assert!(res.is_err());

    // Test setting liquidation health
    let msg = DiraExecuteMsg::SetLiquidationHealth {
        liquidation_health: Decimal::percent(85),
    };
    let res = app.execute_contract(admin.clone(), dira_contract_addr.clone(), &msg, &[]);
    assert!(res.is_ok());

    let res = app.execute_contract(non_admin.clone(), dira_contract_addr.clone(), &msg, &[]);
    assert!(res.is_err());
}

#[test]
fn test_lock_unlock_collateral() {
    let (mut app, dira_contract_addr, _cw20_contract_addr, admin, _non_admin) = setup_app();

    // Set collateral price
    let msg = DiraExecuteMsg::SetCollateralPriceInDirham {
        collateral_price_in_dirham: Decimal::from_ratio(3309u128, 100u128),
    };
    let res = app.execute_contract(admin.clone(), dira_contract_addr.clone(), &msg, &[]);
    assert!(res.is_ok());

    // Lock collateral
    let msg = DiraExecuteMsg::LockCollateral {};
    let res = app.execute_contract(
        admin.clone(),
        dira_contract_addr.clone(),
        &msg,
        &coins(1204, "uatom"),
    );
    assert!(res.is_ok());

    // Unlock collateral
    let msg = DiraExecuteMsg::UnlockCollateral {
        collateral_amount_to_unlock: Decimal::from_atomics(1204u128, 6).unwrap(),
    };
    let res = app.execute_contract(admin.clone(), dira_contract_addr.clone(), &msg, &[]);
    assert!(res.is_ok());

    // Attempt to unlock too much collateral (should fail)
    let msg = DiraExecuteMsg::UnlockCollateral {
        collateral_amount_to_unlock: Decimal::from_atomics(1500u128, 6).unwrap(),
    };
    let res = app.execute_contract(admin.clone(), dira_contract_addr.clone(), &msg, &[]);
    assert!(res.is_err());

    dbg!("Successfully locked and unlocked collateral!");
}

#[test]
fn test_mint_burn_dira() {
    let (mut app, dira_contract_addr, cw20_contract_addr, admin, non_admin) = setup_app();

    // Lock collateral from the admin user
    let set_collateral_price_msg = DiraExecuteMsg::SetCollateralPriceInDirham {
        collateral_price_in_dirham: Decimal::from_ratio(3309u128, 100u128),
    };
    let res = app.execute_contract(
        admin.clone(),
        dira_contract_addr.clone(),
        &set_collateral_price_msg,
        &[],
    );
    assert!(res.is_ok());
    dbg!("Set collateral price");

    let lock_collateral_msg = DiraExecuteMsg::LockCollateral {};
    let res = app.execute_contract(
        admin.clone(),
        dira_contract_addr.clone(),
        &lock_collateral_msg,
        &coins(10_000, "uatom"),
    );
    assert!(res.is_ok());
    dbg!("Locked collateral from admin");

    // Lock collateral from the non-admin user
    let res = app.execute_contract(
        non_admin.clone(),
        dira_contract_addr.clone(),
        &lock_collateral_msg,
        &coins(5_000, "uatom"),
    );
    assert!(res.is_ok());
    dbg!("Locked collateral from non-admin");

    dbg!("Successfully set up mint/burn scenario with collateral locked");

    // Mint DIRA for admin
    let mint_dira_msg = DiraExecuteMsg::MintDira {
        dira_to_mint: Decimal::from_atomics(1_000u128, 6).unwrap(),
    };
    let res = app.execute_contract(
        admin.clone(),
        dira_contract_addr.clone(),
        &mint_dira_msg,
        &[],
    );
    assert!(res.is_ok());
    dbg!("Minted DIRA for admin");

    // Query admin's balance of CW20 DIRA
    let balance_query = cw20::Cw20QueryMsg::Balance {
        address: admin.to_string(),
    };
    let balance: cw20::BalanceResponse = app
        .wrap()
        .query_wasm_smart(cw20_contract_addr.clone(), &balance_query)
        .unwrap();
    assert_eq!(balance.balance, Uint128::new(1_000));
    dbg!("Admin's balance of DIRA:", balance.balance);

    let increase_allowance_msg = Cw20ExecuteMsg::IncreaseAllowance {
        spender: dira_contract_addr.to_string(),
        amount: Uint128::from(500u128), // Approve 500 DIRA tokens
        expires: None,                  // No expiration
    };

    let res = app.execute_contract(
        admin.clone(),              // The user granting the approval
        cw20_contract_addr.clone(), // The CW20 token contract
        &increase_allowance_msg,    // The IncreaseAllowance message
        &[],                        // No funds required
    );
    assert!(res.is_ok());
    dbg!("Successfully granted allowance to Dira contract!");

    // Burn DIRA from admin
    let burn_dira_msg = DiraExecuteMsg::BurnDira {
        dira_to_burn: Decimal::from_atomics(500u128, 6).unwrap(),
    };
    let res = app.execute_contract(
        admin.clone(),
        dira_contract_addr.clone(),
        &burn_dira_msg,
        &[],
    );
    assert!(res.is_ok());
    dbg!("Burnt 500 DIRA from admin");

    // Query admin's balance of CW20 DIRA after burning
    let balance: cw20::BalanceResponse = app
        .wrap()
        .query_wasm_smart(cw20_contract_addr.clone(), &balance_query)
        .unwrap();
    assert_eq!(balance.balance, Uint128::new(500));
    dbg!("Admin's balance of DIRA after burning:", balance.balance);

    // Mint DIRA for non-admin
    let mint_dira_msg = DiraExecuteMsg::MintDira {
        dira_to_mint: Decimal::from_atomics(500u128, 6).unwrap(),
    };
    let res = app.execute_contract(
        non_admin.clone(),
        dira_contract_addr.clone(),
        &mint_dira_msg,
        &[],
    );
    assert!(res.is_ok());
    dbg!("Minted DIRA for non-admin");

    // Query non-admin's balance of CW20 DIRA
    let non_admin_balance_query = cw20::Cw20QueryMsg::Balance {
        address: non_admin.to_string(),
    };
    let balance: cw20::BalanceResponse = app
        .wrap()
        .query_wasm_smart(cw20_contract_addr.clone(), &non_admin_balance_query)
        .unwrap();
    assert_eq!(balance.balance, Uint128::new(500));
    dbg!("Non-admin's balance of DIRA:", balance.balance);

    let increase_allowance_msg = Cw20ExecuteMsg::IncreaseAllowance {
        spender: dira_contract_addr.to_string(),
        amount: Uint128::from(250u128), // Approve 500 DIRA tokens
        expires: None,                  // No expiration
    };

    let res = app.execute_contract(
        non_admin.clone(),          // The user granting the approval
        cw20_contract_addr.clone(), // The CW20 token contract
        &increase_allowance_msg,    // The IncreaseAllowance message
        &[],                        // No funds required
    );
    assert!(res.is_ok());
    dbg!("Successfully granted allowance to Dira contract!");

    // Burn DIRA from non-admin
    let burn_dira_msg = DiraExecuteMsg::BurnDira {
        dira_to_burn: Decimal::from_atomics(250u128, 6).unwrap(),
    };
    let res = app.execute_contract(
        non_admin.clone(),
        dira_contract_addr.clone(),
        &burn_dira_msg,
        &[],
    );
    assert!(res.is_ok());
    dbg!("Burned 250 DIRA from non-admin");

    // Query non-admin's balance of CW20 DIRA after burning
    let balance: cw20::BalanceResponse = app
        .wrap()
        .query_wasm_smart(cw20_contract_addr.clone(), &non_admin_balance_query)
        .unwrap();
    assert_eq!(balance.balance, Uint128::new(250));
    dbg!(
        "Non-admin's balance of DIRA after burning:",
        balance.balance
    );
}

#[test]
fn test_liquidate_collateral() {
    let (mut app, dira_contract_addr, _cw20_contract_addr, admin, user) = setup_app();

    // 1. Setup the environment
    // Step 1.1: Set collateral price
    let set_collateral_price_msg = DiraExecuteMsg::SetCollateralPriceInDirham {
        collateral_price_in_dirham: Decimal::from_ratio(3309u128, 100u128), // 33.09
    };
    let res = app.execute_contract(
        admin.clone(),
        dira_contract_addr.clone(),
        &set_collateral_price_msg,
        &[],
    );
    assert!(res.is_ok());
    dbg!("Set collateral price to 33.09");

    // Step 1.2: Lock collateral from both admin and user
    let lock_collateral_msg = DiraExecuteMsg::LockCollateral {};

    let res = app.execute_contract(
        admin.clone(),
        dira_contract_addr.clone(),
        &lock_collateral_msg,
        &coins(1_000_000, "uatom"), // Admin locks 1 atom
    );
    assert!(res.is_ok());
    dbg!("Locked 1 atom collateral from admin");

    let res = app.execute_contract(
        user.clone(),
        dira_contract_addr.clone(),
        &lock_collateral_msg,
        &coins(1_000_000, "uatom"), // User locks 1 atom
    );
    assert!(res.is_ok());
    dbg!("Locked 1 atom collateral from user");

    // Step 1.3: Mint DIRA for both users
    let mint_dira_msg = DiraExecuteMsg::MintDira {
        dira_to_mint: Decimal::from_ratio(1000000u128, 100000u128),
    };

    let res = app.execute_contract(
        admin.clone(),
        dira_contract_addr.clone(),
        &mint_dira_msg,
        &[],
    );
    assert!(res.is_ok());
    dbg!("Admin minted 1 DIRA");

    let res = app.execute_contract(
        user.clone(),
        dira_contract_addr.clone(),
        &mint_dira_msg,
        &[],
    );
    assert!(res.is_ok());
    dbg!("User minted 1 DIRA");

    // 2. Test liquidation due to price drop
    // Step 2.1: Drop collateral price
    let set_low_collateral_price_msg = DiraExecuteMsg::SetCollateralPriceInDirham {
        collateral_price_in_dirham: Decimal::from_ratio(1000u128, 100u128), // Price drops to 10.00
    };
    let res = app.execute_contract(
        admin.clone(),
        dira_contract_addr.clone(),
        &set_low_collateral_price_msg,
        &[],
    );
    assert!(res.is_ok());
    dbg!("Collateral price dropped to 10.00");

    // Step 2.2: Attempt to liquidate admin from user account
    let liquidate_admin_msg = DiraExecuteMsg::LiquidateStablecoins {
        wallet_address_to_liquidate: admin.clone(),
    };
    let res = app.execute_contract(
        user.clone(),
        dira_contract_addr.clone(),
        &liquidate_admin_msg,
        &[],
    );
    assert!(res.is_ok());
    dbg!("Admin successfully liquidated by user");

    // 3. Test liquidation of user from admin account
    // Step 3.1: Drop collateral price further
    let set_lower_collateral_price_msg = DiraExecuteMsg::SetCollateralPriceInDirham {
        collateral_price_in_dirham: Decimal::from_ratio(500u128, 100u128), // Price drops to 5.00
    };
    let res = app.execute_contract(
        admin.clone(),
        dira_contract_addr.clone(),
        &set_lower_collateral_price_msg,
        &[],
    );
    assert!(res.is_ok());
    dbg!("Collateral price dropped to 5.00");

    // Step 3.2: Attempt to liquidate user from admin account
    let liquidate_user_msg = DiraExecuteMsg::LiquidateStablecoins {
        wallet_address_to_liquidate: user.clone(),
    };
    let res = app.execute_contract(
        admin.clone(),
        dira_contract_addr.clone(),
        &liquidate_user_msg,
        &[],
    );
    assert!(res.is_ok());
    dbg!("User successfully liquidated by admin");

    // 4. Edge Case: Attempt liquidation when health is above threshold
    let invalid_liquidation_msg = DiraExecuteMsg::LiquidateStablecoins {
        wallet_address_to_liquidate: admin.clone(),
    };
    let res = app.execute_contract(
        user.clone(),
        dira_contract_addr.clone(),
        &invalid_liquidation_msg,
        &[],
    );
    assert!(res.is_err());
    dbg!("Liquidation failed as admin's health is above threshold");

    // 5. Edge Case: Liquidation of a wallet with no minted DIRA
    let invalid_liquidation_msg = DiraExecuteMsg::LiquidateStablecoins {
        wallet_address_to_liquidate: Addr::unchecked("cosmos1no_minterxxxxxxxxxxxxxx"),
    };
    let res = app.execute_contract(
        admin.clone(),
        dira_contract_addr.clone(),
        &invalid_liquidation_msg,
        &[],
    );
    assert!(res.is_err());
    dbg!("Liquidation failed for wallet with no minted DIRA");

    // 6. Edge Case: Liquidation attempt on a non-existing user
    let non_existing_user_msg = DiraExecuteMsg::LiquidateStablecoins {
        wallet_address_to_liquidate: Addr::unchecked("cosmos1nonexistentxxxxxxxxxxx"),
    };
    let res = app.execute_contract(
        admin.clone(),
        dira_contract_addr.clone(),
        &non_existing_user_msg,
        &[],
    );
    assert!(res.is_err());
    dbg!("Liquidation failed for non-existing user");
}

#[test]
fn test_query_functions() {
    let (mut app, dira_contract, _cw20_contract, admin, user) = setup_app();

    // Update initial state - Set collateral price
    let set_price_msg = DiraExecuteMsg::SetCollateralPriceInDirham {
        collateral_price_in_dirham: Decimal::from_ratio(2500u128, 100u128), // 25.00
    };
    app.execute_contract(admin.clone(), dira_contract.clone(), &set_price_msg, &[])
        .unwrap();

    // Lock collateral for both admin and user
    let lock_collateral_msg = DiraExecuteMsg::LockCollateral {};
    dbg!(app.execute_contract(
        admin.clone(),
        dira_contract.clone(),
        &lock_collateral_msg,
        &coins(100_000_000_000u128, "uatom"),
    ))
    .unwrap();
    app.execute_contract(
        user.clone(),
        dira_contract.clone(),
        &lock_collateral_msg,
        &coins(100_000_000_000u128, "uatom"),
    )
    .unwrap();

    // Mint DIRA for both admin and user
    let mint_msg = DiraExecuteMsg::MintDira {
        dira_to_mint: Decimal::from_ratio(5000u128, 100u128), // 50 DIRA
    };
    app.execute_contract(admin.clone(), dira_contract.clone(), &mint_msg, &[])
        .unwrap();
    app.execute_contract(user.clone(), dira_contract.clone(), &mint_msg, &[])
        .unwrap();

    // Query locked collateral
    let query_locked = StableDiraQueryMsg::QueryLockedCollateral {
        wallet_address_to_query: admin.clone(),
    };
    let res: CollateralResponse = app
        .wrap()
        .query_wasm_smart(dira_contract.clone(), &query_locked)
        .unwrap();
    assert_eq!(
        res.collateral_locked,
        Decimal::from_ratio(100_000_000_000u128, 1000000u128)
    );
    dbg!("Admin's locked collateral:", res.collateral_locked);

    // Query minted DIRA
    let query_minted = StableDiraQueryMsg::QueryMintedDira {
        wallet_address_to_query: user.clone(),
    };
    let res: MintedDiraResponse = app
        .wrap()
        .query_wasm_smart(dira_contract.clone(), &query_minted)
        .unwrap();
    assert_eq!(res.dira_minted, Decimal::from_ratio(5000u128, 100u128));
    dbg!("User's minted DIRA:", res.dira_minted);

    // Query stablecoin health
    let query_health = StableDiraQueryMsg::QueryStablecoinHealth {
        stablecoin_minter_address_to_query: user.clone(),
    };
    let res: StablecoinHealthResponse = app
        .wrap()
        .query_wasm_smart(dira_contract.clone(), &query_health)
        .unwrap();
    dbg!("User's stablecoin health:", res.health);

    // Query collateral price
    let res: CollateralPriceResponse = app
        .wrap()
        .query_wasm_smart(
            dira_contract.clone(),
            &StableDiraQueryMsg::QueryCollateralPrice {},
        )
        .unwrap();
    assert_eq!(res.collateral_price, Decimal::from_ratio(2500u128, 100u128));
    dbg!("Collateral price:", res.collateral_price);

    // Query liquidation health
    let res: LiquidationHealthResponse = app
        .wrap()
        .query_wasm_smart(
            dira_contract.clone(),
            &StableDiraQueryMsg::QueryLiquidationHealth {},
        )
        .unwrap();
    dbg!("Liquidation health threshold:", res.liquidation_health);

    // Query mintable health
    let res: MintableHealthResponse = app
        .wrap()
        .query_wasm_smart(
            dira_contract.clone(),
            &StableDiraQueryMsg::QueryMintableHealth {},
        )
        .unwrap();
    dbg!("Mintable health threshold:", res.mintable_health);

    // Query admin addresses
    let res: AdminAddressesResponse = app
        .wrap()
        .query_wasm_smart(
            dira_contract.clone(),
            &StableDiraQueryMsg::QueryAdminAddresses {},
        )
        .unwrap();
    dbg!("Admin addresses:", res.admin_addresses);

    // Query collateral token denom
    let res: CollateralTokenDenomResponse = app
        .wrap()
        .query_wasm_smart(
            dira_contract.clone(),
            &StableDiraQueryMsg::QueryCollateralTokenDenom {},
        )
        .unwrap();
    assert_eq!(res.collateral_token_denom, "uatom");
    dbg!("Collateral token denom:", res.collateral_token_denom);

    // Query CW20 DIRA contract address
    let res: CW20DiraContractAddressResponse = app
        .wrap()
        .query_wasm_smart(
            dira_contract.clone(),
            &StableDiraQueryMsg::QueryCW20DiraContractAddress {},
        )
        .unwrap();
    dbg!(
        "CW20 DIRA contract address:",
        res.cw20_dira_contract_address
    );
}

```

Contents of quint/stable_dira_stubs.qnt:
```
// stable_dira_stubs.qnt
// -*- mode: Bluespec; -*-
module stable_dira {
  
  import basicSpells.* from "./lib/basicSpells"
  import cw_types.* from "./lib/cw_types"
  import cw_utils.* from "./lib/cw_utils"
  import messaging.* from "./lib/messaging"
  import bank from "./lib/bank"

  
  var contract_state: ContractState
  var result: Result
  var bank: bank::Bank
  var time: int

  
  pure val CONTRACT_ADDRESS = "contract0"

  
  pure val ADDRESSES = Set("sender1", "sender2", "sender3", CONTRACT_ADDRESS)
  // Assuming 'uatom' is the primary collateral denom based on tests/usage
  pure val DENOMS = Set("uatom", "dira_cw20_placeholder") // Added placeholder for CW20 Dira
  pure val MAX_AMOUNT = 1000000 // Increased based on typical token amounts

  // Types translated from src/msg.rs and src/state.rs
  type InstantiateMsg = {
    liquidation_health: int, // Decimal -> int
    mintable_health: int,    // Decimal -> int
    collateral_token_denom: str,
    cw20_dira_contract_address: Option[Addr],
  }

  type ExecuteMsg =
    | ExecuteMsg_LockCollateral
    | ExecuteMsg_UnlockCollateral({ collateral_amount_to_unlock: int }) // Decimal -> int
    | ExecuteMsg_MintDira({ dira_to_mint: int }) // Decimal -> int
    | ExecuteMsg_BurnDira({ dira_to_burn: int })   // Decimal -> int
    | ExecuteMsg_LiquidateStablecoins({ wallet_address_to_liquidate: Addr })
    | ExecuteMsg_SetCollateralPriceInDirham({ collateral_price_in_dirham: int }) // Decimal -> int
    | ExecuteMsg_SetLiquidationHealth({ liquidation_health: int }) // Decimal -> int
    | ExecuteMsg_SetMintableHealth({ mintable_health: int })       // Decimal -> int
    | ExecuteMsg_SetCW20DiraContractAddress({ cw20_dira_contract_address: Addr })

  // --- Function Stubs ---

  pure def instantiate(state: ContractState, _env: Env, info: MessageInfo, msg: InstantiateMsg): (Result[Response, ContractError], ContractState) = {
    // TODO: Update body based on src/contract.rs:instantiate
    (Ok(Response_new.add_attribute("action", FromStr("instantiate"))), state)
  }

  pure def execute(state: ContractState, _env: Env, info: MessageInfo, msg: ExecuteMsg): (Result[Response, ContractError], ContractState) = match msg {
    | ExecuteMsg_LockCollateral(__r) => lock_collateral(state, info)
    | ExecuteMsg_UnlockCollateral(__r) => unlock_collateral(state, info, __r.collateral_amount_to_unlock)
    | ExecuteMsg_MintDira(__r) => mint_dira(state, info, __r.dira_to_mint)
    | ExecuteMsg_BurnDira(__r) => burn_dira(state, info, __r.dira_to_burn)
    | ExecuteMsg_LiquidateStablecoins(__r) => liquidate_stablecoins(state, info, __r.wallet_address_to_liquidate)
    | ExecuteMsg_SetCollateralPriceInDirham(__r) => set_collateral_price_in_dirham(state, info, __r.collateral_price_in_dirham)
    | ExecuteMsg_SetLiquidationHealth(__r) => set_liquidation_health(state, info, __r.liquidation_health)
    | ExecuteMsg_SetMintableHealth(__r) => set_mintable_health(state, info, __r.mintable_health)
    | ExecuteMsg_SetCW20DiraContractAddress(__r) => set_cw20_dira_contract_address(state, info, __r.cw20_dira_contract_address)
  }

  pure def lock_collateral(state: ContractState, info: MessageInfo): (Result[Response, ContractError], ContractState) = {
    // TODO: Update body based on src/contract.rs:execute_lock_collateral
    (Ok(Response_new), state)
  }
                            
  action lock_collateral_action = {
    // TODO: Change next line according to fund expectations (expecting collateral token denom)
    pure val max_funds = MAX_AMOUNT 
    
    pure val message: ExecuteMsg = ExecuteMsg_LockCollateral
    execute_message(message, max_funds)
  }

  pure def unlock_collateral(state: ContractState, info: MessageInfo, collateral_amount_to_unlock: int): (Result[Response, ContractError], ContractState) = {
    // TODO: Update body based on src/contract.rs:execute_unlock_collateral
    (Ok(Response_new), state)
  }
                            
  action unlock_collateral_action = {
    // TODO: Change next line according to fund expectations (usually 0 for unlock)
    pure val max_funds = 0 
    nondet message_collateral_amount_to_unlock: int = 0.to(MAX_AMOUNT).oneOf()
    pure val message: ExecuteMsg = ExecuteMsg_UnlockCollateral({ collateral_amount_to_unlock: message_collateral_amount_to_unlock })
    execute_message(message, max_funds)
  }

  pure def mint_dira(state: ContractState, info: MessageInfo, dira_to_mint: int): (Result[Response, ContractError], ContractState) = {
    // TODO: Update body based on src/contract.rs:execute_mint_dira
    (Ok(Response_new), state)
  }
                            
  action mint_dira_action = {
    // TODO: Change next line according to fund expectations (usually 0 for mint)
    pure val max_funds = 0
    nondet message_dira_to_mint: int = 0.to(MAX_AMOUNT).oneOf()
    pure val message: ExecuteMsg = ExecuteMsg_MintDira({ dira_to_mint: message_dira_to_mint })
    execute_message(message, max_funds)
  }

  pure def burn_dira(state: ContractState, info: MessageInfo, dira_to_burn: int): (Result[Response, ContractError], ContractState) = {
    // TODO: Update body based on src/contract.rs:execute_burn_dira
    (Ok(Response_new), state)
  }
                            
  action burn_dira_action = {
    // TODO: Change next line according to fund expectations (expecting CW20 transfer/burn approval)
    pure val max_funds = 0 
    nondet message_dira_to_burn: int = 0.to(MAX_AMOUNT).oneOf()
    pure val message: ExecuteMsg = ExecuteMsg_BurnDira({ dira_to_burn: message_dira_to_burn })
    execute_message(message, max_funds)
  }

  pure def liquidate_stablecoins(state: ContractState, info: MessageInfo, wallet_address_to_liquidate: Addr): (Result[Response, ContractError], ContractState) = {
    // TODO: Update body based on src/contract.rs:execute_liquidate_stablecoin_minter
    (Ok(Response_new), state)
  }
                            
  action liquidate_stablecoins_action = {
    // TODO: Change next line according to fund expectations (usually 0)
    pure val max_funds = 0
    nondet message_wallet_address_to_liquidate: Addr = ADDRESSES.oneOf() // Choose an address to liquidate
    pure val message: ExecuteMsg = ExecuteMsg_LiquidateStablecoins({ wallet_address_to_liquidate: message_wallet_address_to_liquidate })
    execute_message(message, max_funds)
  }

  pure def set_collateral_price_in_dirham(state: ContractState, info: MessageInfo, collateral_price_in_dirham: int): (Result[Response, ContractError], ContractState) = {
    // TODO: Update body based on src/contract.rs:execute_set_collateral_price_in_dirham
    (Ok(Response_new), state)
  }
                            
  action set_collateral_price_in_dirham_action = {
    // TODO: Change next line according to fund expectations (0 for admin actions)
    pure val max_funds = 0
    nondet message_collateral_price_in_dirham: int = 1.to(MAX_AMOUNT * 100).oneOf() // Price > 0
    pure val message: ExecuteMsg = ExecuteMsg_SetCollateralPriceInDirham({ collateral_price_in_dirham: message_collateral_price_in_dirham })
    execute_message(message, max_funds)
  }

  pure def set_liquidation_health(state: ContractState, info: MessageInfo, liquidation_health: int): (Result[Response, ContractError], ContractState) = {
    // TODO: Update body based on src/contract.rs:execute_set_liquidation_health
    (Ok(Response_new), state)
  }
                            
  action set_liquidation_health_action = {
    // TODO: Change next line according to fund expectations (0 for admin actions)
    pure val max_funds = 0
    nondet message_liquidation_health: int = 1.to(MAX_AMOUNT).oneOf() // Health > 0
    pure val message: ExecuteMsg = ExecuteMsg_SetLiquidationHealth({ liquidation_health: message_liquidation_health })
    execute_message(message, max_funds)
  }

  pure def set_mintable_health(state: ContractState, info: MessageInfo, mintable_health: int): (Result[Response, ContractError], ContractState) = {
    // TODO: Update body based on src/contract.rs:execute_set_mintable_health
    (Ok(Response_new), state)
  }
                            
  action set_mintable_health_action = {
    // TODO: Change next line according to fund expectations (0 for admin actions)
    pure val max_funds = 0
    nondet message_mintable_health: int = 1.to(MAX_AMOUNT).oneOf() // Health > 0
    pure val message: ExecuteMsg = ExecuteMsg_SetMintableHealth({ mintable_health: message_mintable_health })
    execute_message(message, max_funds)
  }

  pure def set_cw20_dira_contract_address(state: ContractState, info: MessageInfo, cw20_dira_contract_address: Addr): (Result[Response, ContractError], ContractState) = {
    // TODO: Update body based on src/contract.rs:execute_set_cw20_dira_contact_address
    (Ok(Response_new), state)
  }
                            
  action set_cw20_dira_contract_address_action = {
    // TODO: Change next line according to fund expectations (0 for admin actions)
    pure val max_funds = 0
    nondet message_cw20_dira_contract_address: Addr = ADDRESSES.oneOf() // Could be any address initially
    pure val message: ExecuteMsg = ExecuteMsg_SetCW20DiraContractAddress({ cw20_dira_contract_address: message_cw20_dira_contract_address })
    execute_message(message, max_funds)
  }

  // --- State Definition ---

  // Based on src/state.rs
  type ContractState = {
    collateral_token_denom: str,
    admin_addresses: List[Addr],
    liquidation_health: int,    // Decimal -> int
    mintable_health: int,       // Decimal -> int
    locked_collateral: Addr -> int, // Decimal -> int
    minted_dira: Addr -> int,       // Decimal -> int
    collateral_token_price: int, // Decimal -> int
    cw20_dira_contract_address: Addr, // Assuming it gets set, might need Option[Addr]
  }

  // Initial state values
  pure val init_contract_state: ContractState = {
    collateral_token_denom: "", // Set during instantiate
    admin_addresses: [],        // Set during instantiate
    liquidation_health: 0,      // Set during instantiate
    mintable_health: 0,         // Set during instantiate
    locked_collateral: Map(),
    minted_dira: Map(),
    collateral_token_price: 0, // Needs to be set by admin
    cw20_dira_contract_address: "", // Needs to be set by admin or instantiate
  }

  // --- Execution Steps ---

  action execute_step = all {
    any {
      lock_collateral_action,
      unlock_collateral_action,
      mint_dira_action,
      burn_dira_action,
      liquidate_stablecoins_action,
      set_collateral_price_in_dirham_action,
      set_liquidation_health_action,
      set_mintable_health_action,
      set_cw20_dira_contract_address_action
    },
    advance_time,
  }

  // Default reply stub (Needed for boilerplate step action)
  pure def reply(state: ContractState, _env: Env, _reply: Reply): (Result[Response, ContractError], ContractState) = {
      (Ok(Response_new), state)
  }

  // --- Boilerplate Actions ---

  pure val init_bank_state = ADDRESSES.mapBy(_ => DENOMS.mapBy(_ => MAX_AMOUNT))

  val env_val = { block: { time: time, height: 1 } } // TODO: Add a height var if you need it

  action init = {
    // TODO: Fill in InstantiateMsg fields nondeterministically or with defaults
    pure val max_funds = 0 // Instantiate usually takes no funds

    nondet sender = Set("admin").oneOf() // Initial admin
    nondet denom = DENOMS.oneOf()        // Not relevant for instantiate usually
    nondet amount = 0.to(max_funds).oneOf()
    val funds = [{ denom: denom, amount: amount }]
    val info = { sender: sender, funds: funds }

    // Choose reasonable initial values or make them nondeterministic
    nondet init_liquidation_health: int = 110.to(150).oneOf()
    nondet init_mintable_health: int = 130.to(200).oneOf() // Ensure > liquidation
    nondet init_collateral_token_denom: str = Set("uatom").oneOf()
    nondet init_cw20_addr_opt: Option[Addr] = Set(Some("cw20_addr_placeholder"), None).oneOf() // Placeholder

    // Ensure mintable > liquidation if both are nondet
    assume(init_mintable_health > init_liquidation_health)

    pure val message: InstantiateMsg = {
      liquidation_health: init_liquidation_health,
      mintable_health: init_mintable_health,
      collateral_token_denom: init_collateral_token_denom,
      cw20_dira_contract_address: init_cw20_addr_opt,
    }
    // Use init_contract_state as the base, instantiate modifies it
    pure val r = instantiate(init_contract_state, { block: { time: 0, height: 1 } }, info, message)

    all {
      contract_state' = r._2,
      bank' = init_bank_state,
      result' = r._1,
      time' = 0,
    }
  }


  action execute_message(message, max_funds) = {
    nondet sender = ADDRESSES.oneOf()
    nondet denom = DENOMS.oneOf()
    nondet amount = 0.to(max_funds).oneOf()
    val funds = [{ denom: denom, amount: amount }]
    val info = { sender: sender, funds: funds }

    val r = execute(contract_state, env_val, info, message)
    all {
      // Basic bank check, might need refinement based on action
      bank.get(sender).get(denom) >= amount,
      match r._1 {
        // Basic bank update, needs refinement for unlocks/burns etc.
        | Ok(resp) => {
             // Simple model: assume funds go to contract on success unless it's an unlock/burn
             // TODO: Refine based on actual message effects (BankMsg_Send etc in response)
             bank' = bank.setBy(sender, balances => balances.setBy(denom, balance => balance - amount))
                               .setBy(CONTRACT_ADDRESS, balances => balances.setBy(denom, balance => balance + amount))
        }
        | Err(_) => bank' = bank // No bank change on error
      },
      result' = r._1,
      contract_state' = r._2,
    }
  }

  action advance_time = time' = time + 1

  action step = {
    val message_getting = get_message(result)
    val new_result = message_getting._1
    val opt_message = message_getting._2
    match opt_message {
      | Some(submsg) => {
          val current_state = { bank: bank, result: new_result, contract_state: contract_state }
          // process_message needs the reply function defined for the contract
          val new_state = process_message(current_state, env_val, CONTRACT_ADDRESS, submsg, reply)
          all {
            bank' = new_state.bank,
            result' = new_state.result,
            contract_state' = new_state.contract_state,
            advance_time, // Assume time advances even when processing submessages
          }
      }
      | None => execute_step // If no submessages, execute a top-level step
    }
  }

} // End of module stable_dira
```

Contents of quint/lib/bank.qnt:
```
// -*- mode: Bluespec; -*-

module bank {
  import cw_types.* from "./cw_types"
  type Bank = Addr -> Denom -> int

  pure def send(bank: Bank, source_addr: Addr, msg: { to_address: Addr, amount: List[Coin] }): Result[Bank, ContractError] = {
    // FIXME: consider multiple coins
    pure val amount = msg.amount[0].amount
    pure val denom = msg.amount[0].denom
    if (amount >= 0 and bank.get(source_addr).get(denom) >= amount) {
      val new_bank = bank
        .setBy(source_addr, balances => balances.setBy(denom, balance => balance - amount))
        .setBy(msg.to_address, balances => balances.setBy(denom, balance => balance + amount))

      Ok(new_bank)
    } else {
      Err("Not enough balance")
    }
  }

  pure def query_balance(bank: Bank, address: Addr, denom: Denom): Coin = {
    { amount: bank.get(address).get(denom), denom: denom }
  }
}

```

Contents of quint/lib/BoundedUInt.qnt:
```
// -*- mode: Bluespec; -*-

module BoundedUInt {
  /// The size of this integer type in bits.
  const BITS: int

  /// The smallest value that can be represented by this integer type.
  pure val MIN = 0

  /// The largest value that can be represented by this integer type.
  pure val MAX = (2^BITS) - 1
  
  /// Representation of an unsigned, bounded integer.
  ///
  /// - `UInt_Ok(v)` represents the integer `v`, such that `MIN <= v <= MAX`.
  /// - `UInt_Err(msg)` holds a message explaining the out of bounds error.
  ///
  /// NOTE: values of this type must only be constructed using `UInt`,
  /// and never via `Ok` or `Err` directly.
  // TODO: Replace with polymorphic result type, once that is available
  //       See https://github.com/informalsystems/quint/issues/1073
  type UIntT = UInt_Ok(int) | UInt_Err(str)

  /// Given an integer `x`, returns true iff `x` lies in the `[MIN, MAX]` interval.
  pure def isInRange(x: int): bool = MIN <= x and x <= MAX

  /// `UInt(x)` is a bounded unsigned integer if `x` is inside the `[MIN, MAX]` interval,
  /// otherwise it is an `"out of range"` error.
  pure def UInt(x: int): UIntT = if (isInRange(x)) UInt_Ok(x) else UInt_Err("out of range")

  /// `u.bind(x => f(x))` is `f(x)` iff `u` is `UInt_Ok(x)`, i.e., if `u` is a valid bounded int wrapping `x`,
  /// otherwise, when `u` is `UInt_Err(msg)`, it is `u`.
  ///
  /// ## Example
  ///
  /// ```
  /// def checkedIncr(u: UintT): UintT = checkedAdd(u, UIntT(1))
  /// run incr_UintT_twice_test = assert(UInt(0).bind(checkedIncr).bind(checkedIncr) = UInt(2))
  /// ```
  def bind(u: UIntT, f: (int => UIntT)): UIntT = match u {
    | UInt_Ok(i) => f(i)
    | UInt_Err(_) => u
  }

  /// `f.app(u, v, msg)` is `UInt(f(x,y))` if `u` is `UInt_Ok(x)` and `v` is `UInt_Ok(y)`.
  /// If `UInt(f(x,y))` is out of range, it is `UInt_Err(msg)`.
  pure def app(op: (int, int) => int, lhs: UIntT, rhs:UIntT, errMsg: str): UIntT =
    lhs.bind(x => rhs.bind(y =>
      val res = op(x, y)
      if (isInRange(res)) UInt_Ok(res) else UInt_Err(errMsg)))

  /// Computes the absolute difference between lhs and rhs.
  pure def absDiff(lhs: UIntT, rhs: UIntT): UIntT = {
    ((x, y) => {
      val res = x - y
      if (res < 0) -res else res
    }).app(lhs, rhs,
      "impossible")
  }

    ////////////////////////
   // CHECKED OPERATIONS //
  ////////////////////////

  // TODO: In the following we have to eta-expand calls to `ifoo` builtins
  // due to https://github.com/informalsystems/quint/issues/1332
  // We should simplify those once this issue with the simulator is fixed.

  /// Checked integer addition.
  /// Errors with "overflow"
  pure def checkedAdd(lhs: UIntT, rhs: UIntT): UIntT = ((x,y) => iadd(x,y)).app(lhs, rhs, "overflow")

  /// Checked integer subtraction.
  /// Errors with "underflow".
  pure def checkedSub(lhs: UIntT, rhs: UIntT): UIntT = ((x,y) => isub(x,y)).app(lhs, rhs, "underflow")

  /// Checked integer multiplication.
  /// Errors with "overflow".
  pure def checkedMul(lhs: UIntT, rhs: UIntT): UIntT = ((x,y) => imul(x,y)).app(lhs, rhs, "overflow")

  /// Checked integer division.
  /// Errors with "division by zero".
  pure def checkedDiv(lhs: UIntT, rhs: UIntT): UIntT =
    lhs.bind(
      l => rhs.bind(
      r =>
        if (r == 0)
          UInt_Err("division by zero")
        else
          UInt_Ok(l / r)))

  /// Checked integer modulo.
  /// Errors with "division by zero".
  pure def checkedRem(lhs: UIntT, rhs: UIntT): UIntT =
    lhs.bind(
      l => rhs.bind(
      r =>
        if (r == 0)
          UInt_Err("division by zero")
        else
          UInt_Ok(l % r)))

  /// Checked exponentiation.
  /// Errors with "overflow".
  pure def checkedPow(lhs: UIntT, rhs: UIntT): UIntT =
    lhs.bind(
      l => rhs.bind(
      r =>
        if (l == r and l == 0)
          UInt_Err("undefined")
        else
          ((x,y) => ipow(x,y)).app(lhs, rhs, "overflow")))


    ///////////////////////////
   // SATURATING OPERATIONS //
  ///////////////////////////

  /// Saturating integer addition.
  /// Computes `lhs + rhs`, saturating at the numeric bounds instead of overflowing.
  pure def saturatingAdd(lhs: UIntT, rhs: UIntT): UIntT =
    ((x, y) =>
      val res = x + y
      if (res < MAX) res else MAX)
    .app(lhs, rhs, "impossible")

  /// Saturating integer subtraction.
  /// Computes `lhs - rhs`, saturating at the numeric bounds instead of overflowing.
  pure def saturatingSub(lhs: UIntT, rhs: UIntT): UIntT =
    ((x, y) =>
      val res = x - y
      if (res > MIN) res else MIN)
    .app(lhs, rhs, "impossible")

  /// Saturating integer subtraction.
  /// Computes `lhs * rhs`, saturating at the numeric bounds instead of overflowing.
  pure def saturatingMul(lhs: UIntT, rhs: UIntT): UIntT =
    ((x, y) =>
      val res = x * y
      if (res < MAX) res else MAX)
    .app(lhs, rhs, "impossible")

  /// Saturating exponentiation.
  /// Computes `lhs ^ rhs`, saturating at the numeric bounds instead of overflowing.
  pure def saturatingPow(lhs: UIntT, rhs: UIntT): UIntT =
    lhs.bind(
      l => rhs.bind(
      r =>
      if (l == r and l == 0)
        UInt_Err("undefined")
      else
        val res = l ^ r
        UInt_Ok(if (res < MAX) res else MAX)))

    /////////////////////////
   // WRAPPING OPERATIONS //
  /////////////////////////

  /// Wrapping integer addition.
  /// Computes `lhs + rhs`, wrapping around at the boundary of the type.
  pure def wrappingAdd(lhs: UIntT, rhs: UIntT): UIntT =
    ((x, y) => (x + y) % (MAX + 1)).app(lhs, rhs, "impossible")

  pure def wrappingSubInt(x: int, y: int): int = {
    val res = x - y
    val adjusted = if (res < MIN) (res + (MAX + 1)) else res
    adjusted % (MAX + 1)
  }

  /// Wrapping integer subtraction.
  /// Computes `lhs - rhs`, wrapping around at the boundary of the type.
  pure def wrappingSub(lhs: UIntT, rhs: UIntT): UIntT = wrappingSubInt.app(lhs, rhs, "impossible")

  /// Wrapping integer multiplication.
  /// Computes `lhs * rhs`, wrapping around at the boundary of the type.
  pure def wrappingMul(lhs: UIntT, rhs: UIntT): UIntT =
    ((x, y) => (x * y) % (MAX + 1)).app(lhs, rhs, "impossible")

  /// Wrapping integer division.
  /// Computes `lhs / rhs`. Wrapped division on unsigned types is just normal division. 
  /// There’s no way wrapping could ever happen. 
  /// This operator exists, so that all operations are accounted for in the wrapping operations.
  pure def wrappingDiv(lhs: UIntT, rhs: UIntT): UIntT = checkedDiv(lhs, rhs)

  /// Wrapping integer remainder.
  /// Computes `lhs % rhs`. Wrapped remainder on unsigned types is just normal remainder. 
  /// There’s no way wrapping could ever happen. 
  /// This operator exists, so that all operations are accounted for in the wrapping operations.
  pure def wrappingRem(lhs: UIntT, rhs: UIntT): UIntT = checkedRem(lhs, rhs)

  /// Wrapping exponentiation.
  /// Computes `lhs ^ rhs`, wrapping around at the boundary of the type.
  pure def wrappingPow(lhs: UIntT, rhs: UIntT): UIntT =
    lhs.bind(
      l => rhs.bind(
      r =>
      if (l == r and l == 0)
        UInt_Err("undefined")
      else
        UInt_Ok((l ^ r) % (MAX + 1))))
}

module BoundedUInt_Test {
  import BoundedUInt.*

  // Sanity check, tests become degenerate when BITS = 1 (even moreso if <= 0)
  pure val BitsTest = assert(BITS > 1)

  /////////////
  // CHECKED //
  /////////////

  // Checked add
  pure val CAddInvsTest = and {
    assert(checkedAdd(UInt(0), UInt(0)) == UInt_Ok(0)),
    assert(checkedAdd(UInt(1), UInt(0)) == UInt_Ok(1)),
    assert(checkedAdd(UInt(MAX - 1), UInt(0)) == UInt_Ok(MAX - 1)),
    assert(checkedAdd(UInt(MAX), UInt(0)) == UInt_Ok(MAX)),
    assert(checkedAdd(UInt(MAX + 1), UInt(0)) == UInt_Err("out of range")),
    assert(checkedAdd(UInt(0), UInt(MAX)) == UInt_Ok(MAX)),
    assert(checkedAdd(UInt(1), UInt(MAX)) == UInt_Err("overflow")),
    assert(checkedAdd(UInt(MAX - 1), UInt(MAX)) == UInt_Err("overflow")),
    assert(checkedAdd(UInt(MAX), UInt(MAX)) == UInt_Err("overflow")),
    assert(checkedAdd(UInt(MAX), UInt(MAX + 1)) == UInt_Err("out of range")),
  }

  // Checked sub
  pure val CSubInvsTest = and {
    assert(checkedSub(UInt(0), UInt(0)) == UInt_Ok(0)),
    assert(checkedSub(UInt(1), UInt(0)) == UInt_Ok(1)),
    assert(checkedSub(UInt(MAX - 1), UInt(0)) == UInt_Ok(MAX - 1)),
    assert(checkedSub(UInt(MAX), UInt(0)) == UInt_Ok(MAX)),
    assert(checkedSub(UInt(MAX + 1), UInt(0)) == UInt_Err("out of range")),
    assert(checkedSub(UInt(0), UInt(MAX)) == UInt_Err("underflow")),
    assert(checkedSub(UInt(1), UInt(MAX)) ==  UInt_Err("underflow")),
    assert(checkedSub(UInt(MAX - 1), UInt(MAX)) ==  UInt_Err("underflow")),
    assert(checkedSub(UInt(MAX), UInt(MAX)) == UInt_Ok(0)),
    assert(checkedSub(UInt(MAX + 1), UInt(MAX)) == UInt_Err("out of range")),
  }

  // Checked mul
  pure val CMulInvsTest = and {
    assert(checkedMul(UInt(0), UInt(1)) == UInt_Ok(0)),
    assert(checkedMul(UInt(1), UInt(1)) == UInt_Ok(1)),
    assert(checkedMul(UInt(MAX - 1), UInt(1)) == UInt_Ok(MAX - 1)),
    assert(checkedMul(UInt(MAX), UInt(1)) == UInt_Ok(MAX)),
    assert(checkedMul(UInt(MAX + 1), UInt(1)) == UInt_Err("out of range")),
    assert(checkedMul(UInt(0), UInt(MAX)) == UInt_Ok(0)),
    assert(checkedMul(UInt(1), UInt(MAX)) == UInt_Ok(MAX)),
    assert(checkedMul(UInt(MAX - 1), UInt(MAX)) == UInt_Err("overflow")),
    assert(checkedMul(UInt(MAX), UInt(MAX)) == UInt_Err("overflow")),
    assert(checkedMul(UInt(MAX + 1), UInt(MAX)) == UInt_Err("out of range")),
  }

  // Checked div
  pure val CDivInvsTest = and {
    assert(checkedDiv(UInt(0), UInt(0)) == UInt_Err("division by zero")),
    assert(checkedDiv(UInt(1), UInt(0)) == UInt_Err("division by zero")),
    assert(checkedDiv(UInt(MAX - 1), UInt(0)) == UInt_Err("division by zero")),
    assert(checkedDiv(UInt(MAX), UInt(0)) == UInt_Err("division by zero")),
    assert(checkedDiv(UInt(MAX + 1), UInt(0)) == UInt_Err("out of range")),
    assert(checkedDiv(UInt(0), UInt(1)) == UInt_Ok(0)),
    assert(checkedDiv(UInt(1), UInt(1)) == UInt_Ok(1)),
    assert(checkedDiv(UInt(MAX - 1), UInt(1)) == UInt_Ok(MAX - 1)),
    assert(checkedDiv(UInt(MAX), UInt(1)) == UInt_Ok(MAX)),
    assert(checkedDiv(UInt(MAX + 1), UInt(1)) == UInt_Err("out of range")),
    assert(checkedDiv(UInt(0), UInt(MAX)) == UInt_Ok(0)),
    assert(checkedDiv(UInt(1), UInt(MAX)) == UInt_Ok(0)),
    assert(checkedDiv(UInt(MAX - 1), UInt(MAX)) == UInt_Ok(0)),
    assert(checkedDiv(UInt(MAX), UInt(MAX)) == UInt_Ok(1)),
    assert(checkedDiv(UInt(MAX + 1), UInt(MAX)) == UInt_Err("out of range"))
  }

  // Checked rem
  pure val CRemInvsTest = and {
    assert(checkedRem(UInt(0), UInt(0)) == UInt_Err("division by zero")),
    assert(checkedRem(UInt(1), UInt(0)) == UInt_Err("division by zero")),
    assert(checkedRem(UInt(MAX - 1), UInt(0)) == UInt_Err("division by zero")),
    assert(checkedRem(UInt(MAX), UInt(0)) == UInt_Err("division by zero")),
    assert(checkedRem(UInt(MAX + 1), UInt(0)) == UInt_Err("out of range")),
    assert(checkedRem(UInt(0), UInt(1)) == UInt_Ok(0)),
    assert(checkedRem(UInt(1), UInt(1)) == UInt_Ok(0)),
    assert(checkedRem(UInt(MAX - 1), UInt(1)) == UInt_Ok(0)),
    assert(checkedRem(UInt(MAX), UInt(1)) == UInt_Ok(0)),
    assert(checkedRem(UInt(MAX + 1), UInt(1)) == UInt_Err("out of range")),
    assert(checkedRem(UInt(0), UInt(MAX)) == UInt_Ok(0)),
    assert(checkedRem(UInt(1), UInt(MAX)) == UInt_Ok(1)),
    assert(checkedRem(UInt(MAX - 1), UInt(MAX)) == UInt_Ok(MAX - 1)),
    assert(checkedRem(UInt(MAX), UInt(MAX)) == UInt_Ok(0)),
    assert(checkedRem(UInt(MAX + 1), UInt(MAX)) == UInt_Err("out of range"))
  }

  // Checked Pow
  pure val CPowInvsTest = and {
    assert(checkedPow(UInt(0), UInt(0)) == UInt_Err("undefined")),
    assert(checkedPow(UInt(0), UInt(1)) == UInt_Ok(0)),
    assert(checkedPow(UInt(1), UInt(0)) == UInt_Ok(1)),
    assert(checkedPow(UInt(1), UInt(1)) == UInt_Ok(1)),
    assert(checkedPow(UInt(MAX - 1), UInt(1)) == UInt_Ok(MAX - 1)),
    assert(checkedPow(UInt(MAX), UInt(1)) == UInt_Ok(MAX)),
    assert(checkedPow(UInt(MAX), UInt(0)) == UInt_Ok(1)),
    assert(checkedPow(UInt(MAX + 1), UInt(1)) == UInt_Err("out of range")),
    assert(checkedPow(UInt(0), UInt(MAX)) == UInt_Ok(0)),
    assert(checkedPow(UInt(1), UInt(MAX)) == UInt_Ok(1)),
    assert(checkedPow(UInt(2), UInt(BITS - 1)) == UInt_Ok(2^(BITS - 1))),
    assert(checkedPow(UInt(2), UInt(BITS)) == UInt_Err("overflow")),
    assert(checkedPow(UInt(2), UInt(BITS + 1)) == UInt_Err("overflow")),
  }

  ////////////////
  // SATURATING //
  ////////////////

  // Saturating add
  pure val SAddInvsTest = and {
    assert(saturatingAdd(UInt(0), UInt(0)) == UInt_Ok(0)),
    assert(saturatingAdd(UInt(1), UInt(0)) == UInt_Ok(1)),
    assert(saturatingAdd(UInt(MAX - 1), UInt(0)) == UInt_Ok(MAX - 1)),
    assert(saturatingAdd(UInt(MAX), UInt(0)) == UInt_Ok(MAX)),
    assert(saturatingAdd(UInt(MAX + 1), UInt(0)) == UInt_Err("out of range")),
    assert(saturatingAdd(UInt(0), UInt(MAX)) == UInt_Ok(MAX)),
    assert(saturatingAdd(UInt(1), UInt(MAX)) == UInt_Ok(MAX)),
    assert(saturatingAdd(UInt(MAX - 1), UInt(MAX)) == UInt_Ok(MAX)),
    assert(saturatingAdd(UInt(MAX), UInt(MAX)) == UInt_Ok(MAX)),
    assert(saturatingAdd(UInt(MAX + 1), UInt(MAX)) == UInt_Err("out of range"))
  }

  // Saturating sub
  pure val SSubInvsTest = and {
    assert(saturatingSub(UInt(0), UInt(0)) == UInt_Ok(0)),
    assert(saturatingSub(UInt(1), UInt(0)) == UInt_Ok(1)),
    assert(saturatingSub(UInt(0), UInt(1)) == UInt_Ok(0)),
    assert(saturatingSub(UInt(MAX - 1), UInt(0)) == UInt_Ok(MAX - 1)),
    assert(saturatingSub(UInt(MAX), UInt(0)) == UInt_Ok(MAX)),
    assert(saturatingSub(UInt(MAX + 1), UInt(0)) == UInt_Err("out of range")),
    assert(saturatingSub(UInt(0), UInt(MAX)) == UInt_Ok(0)),
    assert(saturatingSub(UInt(1), UInt(MAX)) == UInt_Ok(0)),
    assert(saturatingSub(UInt(MAX - 1), UInt(MAX)) == UInt_Ok(0)),
    assert(saturatingSub(UInt(MAX), UInt(MAX)) == UInt_Ok(0)),
    assert(saturatingSub(UInt(MAX + 1), UInt(MAX)) == UInt_Err("out of range"))
  }

  // Saturating mul
  pure val SMulInvsTest = and {
    assert(saturatingMul(UInt(0), UInt(1)) == UInt_Ok(0)),
    assert(saturatingMul(UInt(1), UInt(1)) == UInt_Ok(1)),
    assert(saturatingMul(UInt(MAX - 1), UInt(1)) == UInt_Ok(MAX - 1)),
    assert(saturatingMul(UInt(MAX), UInt(1)) == UInt_Ok(MAX)),
    assert(saturatingMul(UInt(MAX + 1), UInt(1)) == UInt_Err("out of range")),
    assert(saturatingMul(UInt(0), UInt(MAX)) == UInt_Ok(0)),
    assert(saturatingMul(UInt(1), UInt(MAX)) == UInt_Ok(MAX)),
    assert(saturatingMul(UInt(MAX - 1), UInt(MAX)) == UInt_Ok(MAX)),
    assert(saturatingMul(UInt(MAX), UInt(MAX)) == UInt_Ok(MAX)),
    assert(saturatingMul(UInt(MAX + 1), UInt(MAX)) == UInt_Err("out of range"))
  }

  // Saturating pow
  pure val SPowInvsTest = and {
    assert(saturatingPow(UInt(0), UInt(0)) == UInt_Err("undefined")),
    assert(saturatingPow(UInt(0), UInt(1)) == UInt_Ok(0)),
    assert(saturatingPow(UInt(1), UInt(0)) == UInt_Ok(1)),
    assert(saturatingPow(UInt(1), UInt(1)) == UInt_Ok(1)),
    assert(saturatingPow(UInt(MAX - 1), UInt(1)) == UInt_Ok(MAX - 1)),
    assert(saturatingPow(UInt(MAX), UInt(1)) == UInt_Ok(MAX)),
    assert(saturatingPow(UInt(MAX + 1), UInt(1)) == UInt_Err("out of range")),
    assert(saturatingPow(UInt(0), UInt(MAX)) == UInt_Ok(0)),
    assert(saturatingPow(UInt(1), UInt(MAX)) == UInt_Ok(1)),
    assert(saturatingPow(UInt(2), UInt(BITS - 1)) == UInt_Ok(2^(BITS - 1))),
    assert(saturatingPow(UInt(2), UInt(BITS)) == UInt_Ok(MAX)),
    assert(saturatingPow(UInt(2), UInt(BITS + 1)) == UInt_Ok(MAX)),
  }

  //////////////
  // WRAPPING //
  //////////////

  // Wrapping add
  pure val WAddInvsTest = and {
    assert(wrappingAdd(UInt(0), UInt(0)) == UInt_Ok(0)),
    assert(wrappingAdd(UInt(1), UInt(0)) == UInt_Ok(1)),
    assert(wrappingAdd(UInt(MAX - 1), UInt(0)) == UInt_Ok(MAX - 1)),
    assert(wrappingAdd(UInt(MAX), UInt(0)) == UInt_Ok(MAX)),
    assert(wrappingAdd(UInt(MAX), UInt(1)) == UInt_Ok(0)),
    assert(wrappingAdd(UInt(MAX + 1), UInt(0)) == UInt_Err("out of range")),
    assert(wrappingAdd(UInt(0), UInt(MAX)) == UInt_Ok(MAX)),
    assert(wrappingAdd(UInt(1), UInt(MAX)) == UInt_Ok(0)),
    assert(wrappingAdd(UInt(MAX - 1), UInt(MAX)) == UInt_Ok(MAX - 2)),
    assert(wrappingAdd(UInt(MAX), UInt(MAX)) == UInt_Ok(MAX - 1)),
    assert(wrappingAdd(UInt(MAX + 1), UInt(MAX)) == UInt_Err("out of range"))
  }

  // Wrapping sub
  pure val WSubInvsTest = and {
    assert(wrappingSub(UInt(0), UInt(0)) == UInt_Ok(0)),
    assert(wrappingSub(UInt(1), UInt(0)) == UInt_Ok(1)),
    assert(wrappingSub(UInt(0), UInt(1)) == UInt_Ok(MAX)),
    assert(wrappingSub(UInt(1), UInt(1)) == UInt_Ok(0)),
    assert(wrappingSub(UInt(MAX - 1), UInt(0)) == UInt_Ok(MAX - 1)),
    assert(wrappingSub(UInt(MAX), UInt(0)) == UInt_Ok(MAX)),
    assert(wrappingSub(UInt(MAX + 1), UInt(0)) == UInt_Err("out of range")),
    assert(wrappingSub(UInt(0), UInt(MAX)) == UInt_Ok(1)),
    assert(wrappingSub(UInt(1), UInt(MAX)) == UInt_Ok(2)),
    assert(wrappingSub(UInt(MAX - 1), UInt(MAX)) == UInt_Ok(MAX)),
    assert(wrappingSub(UInt(MAX), UInt(MAX)) == UInt_Ok(0)),
    assert(wrappingSub(UInt(MAX + 1), UInt(MAX)) == UInt_Err("out of range"))
  }

  // Wrapping mul
  pure val WMulInvsTest = and {
    assert(wrappingMul(UInt(0), UInt(1)) == UInt_Ok(0)),
    assert(wrappingMul(UInt(1), UInt(1)) == UInt_Ok(1)),
    assert(wrappingMul(UInt(MAX - 1), UInt(1)) == UInt_Ok(MAX - 1)),
    assert(wrappingMul(UInt(MAX), UInt(1)) == UInt_Ok(MAX)),
    assert(wrappingMul(UInt(MAX + 1), UInt(1)) == UInt_Err("out of range")),
    assert(wrappingMul(UInt(0), UInt(MAX)) == UInt_Ok(0)),
    assert(wrappingMul(UInt(1), UInt(MAX)) == UInt_Ok(MAX)),
    assert(wrappingMul(UInt(MAX - 1), UInt(MAX)) == UInt_Ok(2)),
    assert(wrappingMul(UInt(MAX), UInt(MAX)) == UInt_Ok(1)),
    assert(wrappingMul(UInt(MAX + 1), UInt(MAX)) == UInt_Err("out of range"))
  }

  // Wrapping div == checked div
  // Wrapping rem == checked rem
  
  // Wrapping Pow
  pure val WPowInvsTest = and {
    assert(wrappingPow(UInt(0), UInt(0)) == UInt_Err("undefined")),
    assert(wrappingPow(UInt(0), UInt(1)) == UInt_Ok(0)),
    assert(wrappingPow(UInt(1), UInt(0)) == UInt_Ok(1)),
    assert(wrappingPow(UInt(1), UInt(1)) == UInt_Ok(1)),
    assert(wrappingPow(UInt(MAX - 1), UInt(1)) == UInt_Ok(MAX - 1)),
    assert(wrappingPow(UInt(MAX), UInt(1)) == UInt_Ok(MAX)),
    assert(wrappingPow(UInt(MAX + 1), UInt(1)) == UInt_Err("out of range")),
    assert(wrappingPow(UInt(0), UInt(MAX)) == UInt_Ok(0)),
    assert(wrappingPow(UInt(1), UInt(MAX)) == UInt_Ok(1)),
    assert(wrappingPow(UInt(2), UInt(BITS - 1)) == UInt_Ok(2^(BITS - 1))),
    assert(wrappingPow(UInt(2), UInt(BITS)) == UInt_Ok(0)),
    assert(wrappingPow(UInt(2), UInt(BITS + 1)) == UInt_Ok(0)),
  }

  //////////////
  // ABS DIFF //
  //////////////

  pure val AbsDiffTest = and {
    assert(absDiff(UInt(0), UInt(1)) == UInt_Ok(1)),
    assert(absDiff(UInt(1), UInt(1)) == UInt_Ok(0)),
    assert(absDiff(UInt(MAX - 1), UInt(1)) == UInt_Ok(MAX - 2)),
    assert(absDiff(UInt(MAX), UInt(1)) == UInt_Ok(MAX - 1)),
    assert(absDiff(UInt(MAX + 1), UInt(1)) == UInt_Err("out of range")),
    assert(absDiff(UInt(0), UInt(MAX)) == UInt_Ok(MAX)),
    assert(absDiff(UInt(1), UInt(MAX)) == UInt_Ok(MAX - 1)),
    assert(absDiff(UInt(MAX - 1), UInt(MAX)) == UInt_Ok(1)),
    assert(absDiff(UInt(MAX), UInt(MAX)) == UInt_Ok(0)),
    assert(absDiff(UInt(MAX + 1), UInt(MAX)) == UInt_Err("out of range"))
  }

}

module BoundedUInt8Test {
  import BoundedUInt_Test(BITS = 8).*
}

module BoundedUInt16Test {
  import BoundedUInt_Test(BITS = 16).*
}

module BoundedUInt32Test {
  import BoundedUInt_Test(BITS = 32).*
}

```

Contents of quint/lib/basicSpells.qnt:
```
// -*- mode: Bluespec; -*-
/**
 * This module collects definitions that are ubiquitous.
 * One day they will become the standard library of Quint.
 */
module basicSpells {
  type Option[a] = Some(a) | None

  /// An annotation for writing preconditions.
  /// - @param __cond condition to check
  /// - @returns true if and only if __cond evaluates to true
  pure def require(__cond: bool): bool = __cond

  run requireTest = all {
    assert(require(4 > 3)),
    assert(not(require(false))),
  }

  /// A convenience operator that returns a string error code,
  ///  if the condition does not hold true.
  ///
  /// - @param __cond condition to check
  /// - @param __error a non-empty error message
  /// - @returns "", when __cond holds true; otherwise __error
  pure def requires(__cond: bool, __error: str): str = {
    if (__cond) "" else __error
  }

  run requiresTest = all {
    assert(requires(4 > 3, "4 > 3") == ""),
    assert(requires(4 < 3, "false: 4 < 3") == "false: 4 < 3"),
  }


  /// Compute the maximum of two integers.
  ///
  /// - @param __i first integer
  /// - @param __j second integer
  /// - @returns the maximum of __i and __j
  pure def max(__i: int, __j: int): int = {
    if (__i > __j) __i else __j
  }

  run maxTest = all {
    assert(max(3, 4) == 4),
    assert(max(6, 3) == 6),
    assert(max(10, 10) == 10),
    assert(max(-3, -5) == -3),
    assert(max(-5, -3) == -3),
  }

  /// Compute the absolute value of an integer
  ///
  /// - @param __i : an integer whose absolute value we are interested in
  /// - @returns |__i|, the absolute value of __i
  pure def abs(__i: int): int = {
    if (__i < 0) -__i else __i
  }

  run absTest = all {
    assert(abs(3) == 3),
    assert(abs(-3) == 3),
    assert(abs(0) == 0),
  }

  /// Remove a set element.
  ///
  /// - @param __set a set to remove an element from
  /// - @param __elem an element to remove
  /// - @returns a new set that contains all elements of __set but __elem
  pure def setRemove(__set: Set[a], __elem: a): Set[a] = {
    __set.exclude(Set(__elem))
  }

  run setRemoveTest = all {
    assert(Set(2, 4) == Set(2, 3, 4).setRemove(3)),
    assert(Set() == Set().setRemove(3)),
  }

  /// Test whether a key is present in a map
  ///
  /// - @param __map a map to query
  /// - @param __key the key to look for
  /// - @returns true if and only __map has an entry associated with __key
  pure def has(__map: a -> b, __key: a): bool = {
    __map.keys().contains(__key)
  }

  run hasTest = all {
    assert(Map(2 -> 3, 4 -> 5).has(2)),
    assert(not(Map(2 -> 3, 4 -> 5).has(6))),
  }

  /// Get the map value associated with a key, or the default,
  /// if the key is not present.
  ///
  /// - @param __map the map to query
  /// - @param __key the key to search for
  /// - @returns the value associated with the key, if __key is
  ///   present in the map, and __default otherwise
  pure def getOrElse(__map: a -> b, __key: a, __default: b): b = {
    if (__map.has(__key)) {
      __map.get(__key)
    } else {
      __default
    }
  }

  run getOrElseTest = all {
    assert(Map(2 -> 3, 4 -> 5).getOrElse(2, 0) == 3),
    assert(Map(2 -> 3, 4 -> 5).getOrElse(7, 11) == 11),
  }

  /// Remove a map entry.
  ///
  /// - @param __map a map to remove an entry from
  /// - @param __key the key of an entry to remove
  /// - @returns a new map that contains all entries of __map
  ///          that do not have the key __key
  pure def mapRemove(__map: a -> b, __key: a): a -> b = {
    __map.keys().setRemove(__key).mapBy(__k => __map.get(__k))
  }

  run mapRemoveTest = all {
    assert(Map(3 -> 4, 7 -> 8) == Map(3 -> 4, 5 -> 6, 7 -> 8).mapRemove(5)),
    assert(Map() == Map().mapRemove(3)),
  }

  /// Removes a set of map entries.
  ///
  /// - @param __map a map to remove entries from
  /// - @param __keys a set of keys for entries to remove from the map
  /// - @returns a new map that contains all entries of __map
  ///          that do not have a key in __keys
  pure def mapRemoveAll(__map: a -> b, __keys: Set[a]): a -> b = {
      __map.keys().exclude(__keys).mapBy(__k => __map.get(__k))
  }

  run mapRemoveAllTest =
      val m = Map(3 -> 4, 5 -> 6, 7 -> 8)
      all {
          assert(m.mapRemoveAll(Set(5, 7)) == Map(3 -> 4)),
          assert(m.mapRemoveAll(Set(5, 99999)) == Map(3 -> 4, 7 -> 8)),
      }

  /// Get the set of values of a map.
  ///
  /// - @param __map a map from type a to type b
  /// - @returns the set of all values in the map
  pure def values(__map: a -> b): Set[b] = {
    __map.keys().map(k => __map.get(k))
  }

  run valuesTest = all {
    assert(values(Map()) == Set()),
    assert(values(Map(1 -> 2, 2 -> 3)) == Set(2, 3)),
    assert(values(Map(1 -> 2, 2 -> 3, 3 -> 2)) == Set(2, 3)),
  }

  /// Whether a set is empty
  ///
  /// - @param s a set of any type
  /// - @returns true iff the set is the empty set
  pure def empty(s: Set[a]): bool = s == Set()

  run emptyTest = all {
    assert(empty(Set()) == true),
    assert(empty(Set(1, 2)) == false),
    assert(empty(Set(Set())) == false),
  }

  pure def listFilter(l: List[a], f: (a) => bool): List[a] =
    l.foldl([], (acc, e) => if (f(e)) acc.append(e) else acc)

  pure def listMap(l: List[a], f: (a) => b): List[b] =
    l.foldl([], (acc, e) => acc.append(f(e)))

  //// Returns a set of the elements in the list.
  ////
  //// - @param l a list
  //// - @returns a set of the elements in l
  pure def toSet(l: List[a]): Set[a] = {
      l.foldl(Set(), (s, e) => s.union(Set(e)))
  }
}

```

Contents of quint/lib/cw_types.qnt:
```
// -*- mode: Bluespec; -*-

module cw_types {
  import basicSpells.* from "./basicSpells"

  type Addr = str
  type Denom = str

  type TODO = str
  type ContractError = str

  type ReplyOn =
    | ReplyOn_Always
    | ReplyOn_Error
    | ReplyOn_Success
    | ReplyOn_Never

  type SubMsg = { id: int, msg: CosmosMsg, reply_on: ReplyOn, gas_limit: Option[int] }
  type Attribute = { key: str, value: CW_Serialized }
  type Event = { ty: str, attributes: List[Attribute] }

  type Response = {
    messages: List[SubMsg],
    attributes: List[Attribute],
    events: List[Event],
    data: Option[str],
  }

  type CosmosMsg =
    | CosmosMsg_Wasm(WasmMsg)
    | CosmosMsg_Bank(BankMsg)
    // | CosmosMsg_Custom(T)
    // | CosmosMsg_Staking(StakingMsg)
    // | CosmosMsg_Distribution(DistributionMsg)

  type WasmMsg =
    | WasmMsg_Instantiate({
        admin: Option[str],
        code_id: int,
        // msg is the JSON-encoded InstantiateMsg struct (as raw Binary)
        // msg: InstantiateMsg, // TODO: we need polymorphism
        funds: List[Coin],
        // A human-readable label for the contract.
        //
        // Valid values should:
        // - not be empty
        // - not be bigger than 128 bytes (or some chain-specific limit)
        // - not start / end with whitespace
        label: str,
    })
    // | Execute(...)

  type BankMsg =
    | BankMsg_Send({ to_address: str, amount: List[Coin] })

  pure val Response_new = { messages: [], attributes: [], events: [], data: None }

  /// This is used for cases when we use ReplyOn::Never and the id doesn't matter
  pure val UNUSED_MSG_ID = 0

  pure def SubMsg_new(msg: CosmosMsg): SubMsg = {
    id: UNUSED_MSG_ID,
    msg: msg,
    reply_on: ReplyOn_Never,
    gas_limit: None,
  }

  pure def SubMsg_reply_on_success(msg: CosmosMsg, id: int): SubMsg = {
    __reply_on(msg, id, ReplyOn_Success)
  }

  pure def SubMsg_reply_on_error(msg: CosmosMsg, id: int): SubMsg = {
    __reply_on(msg, id, ReplyOn_Error)
  }

  pure def SubMsg_reply_always(msg: CosmosMsg, id: int): SubMsg = {
    __reply_on(msg, id, ReplyOn_Always)
  }

  pure def with_gas_limit(msg: SubMsg, limit: int): SubMsg = {
    { ...msg, gas_limit: Some(limit) }
  }

  pure def __reply_on(msg: CosmosMsg, id: int, reply_on: ReplyOn): SubMsg = {
    {
      id: id,
      msg: msg,
      reply_on: reply_on,
      gas_limit: None,
    }
  }

  def should_reply_on_success(r) = match r {
    | ReplyOn_Always => true
    | ReplyOn_Success => true
    | _ => false
  }

  def should_reply_on_error(r: ReplyOn): bool = match r {
    | ReplyOn_Always => true
    | ReplyOn_Error => true
    | _ => false
  }

  type SubMsgResponse = {
    events: List[Event],
    data: Option[CW_Serialized]
  }

  type Reply = {
    id: int,
    result: Result[SubMsgResponse, ContractError],
  }

  pure def add_attribute(r: Response, k: str, v: CW_Serialized): Response = {
    val attribute = { key: k, value: v }
    { ...r, attributes: r.attributes.append(attribute) }
  }

  pure def add_message(r: Response, m: CosmosMsg): Response = {
    { ...r, messages: r.messages.append(SubMsg_new(m)) }
  }

  pure def add_submessage(r: Response, m: SubMsg): Response = {
    { ...r, messages: r.messages.append(m) }
  }

  type Result[ok, err] = Ok(ok) | Err(err)

  type Deps = {
    storage: TODO,
    api: TODO,
    querier: TODO,
  }

  type BlockInfo = { time: int, height: int }
  type Env = { block: BlockInfo }

  type Coin = {
    denom: str,
    amount: int
  }

  type MessageInfo = {
    sender: str,
    funds: List[Coin]
  }

  type CW_Serialized =
    | FromStr(str)
    | FromInt(int)
    | FromListInt(List[int])

  // These shouldn't be actually used, but they are here for completion
  type MultiIndex[ik, t, pk] = ()
  type IndexedMap[k, t i] = ()

  type StdError = str
  type StdResult[a] = Result[a, StdError]

  // There's no dynamic dispatch in Quint, so the best we can do is to have a
  // special string argument to identify a behavior and then have the
  // implementation depend on it
  type TraitObject = str
}

```

Contents of quint/lib/cw_utils.qnt:
```
// -*- mode: Bluespec; -*-

// https://docs.rs/cw-utils/0.13.4/src/cw_utils/payment.rs.html#32-39
module cw_utils {
  import cw_types.* from "./cw_types"

  type Expiration =
    // AtHeight will expire when `env.block.height` >= height
    | Expiration_AtHeight(int)
    // AtTime will expire when `env.block.time` >= time
    | Expiration_AtTime(int)
    // Never will never expire. Used to express the empty variant
    | Expiration_Never

  type Duration =
    | Duration_Height(int)
    // Time in seconds
    | Duration_Time(int)

  def one_coin(info: MessageInfo): Result[Coin, ContractError] = {
    if (info.funds.indices().size() == 0) {
      Err("No funds")
    } else if (info.funds.indices().size() == 1) {
      val coin = info.funds[0]
      if (coin.amount == 0) {
        Err("Zero funds")
      } else {
        Ok(coin)
      }
    } else {
      Err("Multiple Denoms")
    }
  }

  def must_pay(info: MessageInfo, denom: str): Result[int, ContractError] = {
    match one_coin(info) {
      | Err(err) => Err(err)
      | Ok(coin) => {
        if (coin.denom != denom) {
          Err("Wrong Denom")
        } else {
          Ok(coin.amount)
        }
      }
    }
  }
}

```

Contents of quint/lib/messaging.qnt:
```
// -*- mode: Bluespec; -*-

module messaging {
  import cw_types.* from "./cw_types"
  import bank from "./bank"
  import basicSpells.* from "./basicSpells"

  pure def get_message(result_val: Result[Response, ContractError]): (Result[Response, ContractError], Option[SubMsg]) = {
    match result_val {
      | Ok(response) =>
        if (response.messages.indices().size() > 0) {
          val submsg = response.messages.head()
          val new_result = Ok({ ...response, messages: response.messages.listFilter(m => m != submsg) })
          (new_result, Some(submsg))
        } else {
          (result_val, None)
        }

      | _ => (result_val, None)
    }
  }

  pure def process_message(state, env, contract_address, submsg, reply) = {
    match submsg.msg {
      | CosmosMsg_Wasm(wasm_msg) => state // FIXME
      | CosmosMsg_Bank(bank_msg) =>
        match bank_msg {
          | BankMsg_Send(msg) => match bank::send(state.bank, contract_address, msg) {
            | Ok(new_bank) =>
               if (should_reply_on_success(submsg.reply_on)) {
                 val reply_result = reply(state.contract_state, env, { id: submsg.id, result: Ok({ events: [/* TODO */], data: None }) })
                 { bank: new_bank, result: reply_result._1, contract_state: reply_result._2 }
               } else {
                 { ...state, bank: new_bank }
               }
            | Err(err) =>
               if (should_reply_on_error(submsg.reply_on)) {
                 val reply_result = reply(state.contract_state, env, { id: submsg.id, result: Err(err) })
                 { ...state, result: reply_result._1, contract_state: reply_result._2 }
               } else {
                  { ...state, result: Err(err) }
               }
           }
        }
    }
  }
}

```

Contents of src/error.rs:
```
use cosmwasm_std::{Decimal, StdError};
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ContractError {
    #[error("{0}")]
    Std(#[from] StdError),

    #[error("The user is not an admin authorized to perform this action")]
    UnauthorizedUser {},

    #[error("Insufficient funds sent, or funds sent with the incorrect token")]
    InsufficientFundsSent {},

    #[error("Not enough collateral locked")]
    InsufficientCollateral {},

    #[error("Liquidation health or mintable health cannot be zero")]
    HealthCannotBeZero {},

    #[error("Unlock amount too high. Max unlockable tokens: {max_unlockable}")]
    UnlockAmountTooHigh { max_unlockable: Decimal },

    #[error("Collateral Token Denom has not been set")]
    MissingCollateralTokenDenom {},

    #[error("Mintable Health cannot be set to be lower than Liquidation Health")]
    MintableHealthLowerThanLiquidationHealth {},

    #[error("Collateral price has not been set")]
    CollateralPriceNotSet {},

    #[error("Cannot return more Dira than minted")]
    ReturningMoreDiraThanMinted {},

    #[error("Invalid Wallet Address")]
    InvalidWalletAddress {},

    #[error("Invalid CW20 Contract Address")]
    InvalidCW20ContractAddress {},

    #[error("CW20 Dira Contract Address not set")]
    CW20DiraContractAddressNotSet {},

    #[error("{wallet_address}'s Dira are too healthy to liquidate")]
    TooHealthyToLiquidate{ wallet_address: cosmwasm_std::Addr }

    // Add any other custom errors you like here.
    // Look at https://docs.rs/thiserror/1.0.21/thiserror/ for details.
}

```

Contents of src/lib.rs:
```
pub mod contract;
mod error;
pub mod msg;
pub mod state;

pub use crate::error::ContractError;
```

Contents of src/schema.rs:
```
// use cosmwasm_schema::{export_schema, remove_schemas, schema_for};
// use std::env::current_dir;
// use std::fs::{create_dir_all, remove_file};
// use std::path::PathBuf;

// use stable_dira::msg::{
//     AdminAddressesResponse, CW20DiraContractAddressResponse, CollateralPriceResponse,
//     CollateralResponse, CollateralTokenDenomResponse, ExecuteMsg, InstantiateMsg,
//     LiquidationHealthResponse, MintableHealthResponse, MintedDiraResponse, QueryMsg,
//     StablecoinHealthResponse,
// };

// use schemars::JsonSchema;
// use serde::Serialize;

// fn main() {
//     let mut out_dir = current_dir().unwrap();
//     out_dir.push("schema");

//     // Clean and recreate schema directory
//     create_dir_all(&out_dir).unwrap();
//     remove_schemas(&out_dir).unwrap();

//     // Export schemas for standard types
//     export_schema(&schema_for!(InstantiateMsg), &out_dir);
//     export_schema(&schema_for!(ExecuteMsg), &out_dir);
//     export_schema(&schema_for!(QueryMsg), &out_dir);

//     // Export individual query response schemas
//     let response_types = vec![
//         ("collateral_response", schema_for!(CollateralResponse)),
//         ("minted_dira_response", schema_for!(MintedDiraResponse)),
//         (
//             "stablecoin_health_response",
//             schema_for!(StablecoinHealthResponse),
//         ),
//         (
//             "collateral_price_response",
//             schema_for!(CollateralPriceResponse),
//         ),
//         (
//             "liquidation_health_response",
//             schema_for!(LiquidationHealthResponse),
//         ),
//         (
//             "mintable_health_response",
//             schema_for!(MintableHealthResponse),
//         ),
//         (
//             "admin_addresses_response",
//             schema_for!(AdminAddressesResponse),
//         ),
//         (
//             "collateral_token_denom_response",
//             schema_for!(CollateralTokenDenomResponse),
//         ),
//         (
//             "c_w20_dira_contract_address_response",
//             schema_for!(CW20DiraContractAddressResponse),
//         ),
//     ];

//     // Export individual files and store their paths
//     let mut individual_files: Vec<PathBuf> = Vec::new();
//     for (name, schema) in response_types.iter() {
//         let file_name = format!("{}.json", name);
//         let file_path = out_dir.join(&file_name);
//         export_schema(schema, &out_dir);
//         individual_files.push(file_path);
//     }

//     // Combine all query responses into a single schema file
//     #[derive(Serialize, JsonSchema)] // Add JsonSchema here
//     struct QueryResponseMsg {
//         collateral_response: CollateralResponse,
//         minted_dira_response: MintedDiraResponse,
//         stablecoin_health_response: StablecoinHealthResponse,
//         collateral_price_response: CollateralPriceResponse,
//         liquidation_health_response: LiquidationHealthResponse,
//         mintable_health_response: MintableHealthResponse,
//         admin_addresses_response: AdminAddressesResponse,
//         collateral_token_denom_response: CollateralTokenDenomResponse,
//         cw20_dira_contract_address_response: CW20DiraContractAddressResponse,
//     }

//     export_schema(&schema_for!(QueryResponseMsg), &out_dir);
//     println!("Combined query responses schema created.");

//     // Delete individual query response files
//     for file in individual_files {
//         if let Err(e) = remove_file(&file) {
//             eprintln!("Failed to delete file {:?}: {}", file, e);
//         } else {
//             println!("Deleted individual file: {:?}", file);
//         }
//     }
// }

use stable_dira::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};
use cosmwasm_schema::write_api;
 
fn main() {
    write_api! {
        instantiate: InstantiateMsg,
        execute: ExecuteMsg,
        query: QueryMsg
    }
}
```

Contents of src/state.rs:
```
use cosmwasm_std::{Addr, Decimal};

// What token is allowed to be used as collateral for Dira
pub const COLLATERAL_TOKEN_DENOM: cw_storage_plus::Item<String> =
    cw_storage_plus::Item::new("native-token-name");

// List of admin addresses that are allowed to change parameters of the contract
pub const ADMIN_ADDRESSES: cw_storage_plus::Item<Vec<Addr>> =
    cw_storage_plus::Item::new("admin-addresses");

// Admin changeable, below what health of the collateral for the stablecoin can
// a user's collateral be liquidated?
pub const LIQUIDATION_HEALTH: cw_storage_plus::Item<Decimal> =
    cw_storage_plus::Item::new("liquidation-health");

// Admin changeable, what is the lowest health at which a user can mint stablecoins
// has to be higher than the liquidation health
pub const MINTABLE_HEALTH: cw_storage_plus::Item<Decimal> = 
    cw_storage_plus::Item::new("mintable-health");

// Track collateral locked by each wallet
pub const LOCKED_COLLATERAL: cw_storage_plus::Map<Addr, Decimal> =
    cw_storage_plus::Map::new("locked-collaterals");

// Track dira minted by each wallet
pub const MINTED_DIRA: cw_storage_plus::Map<Addr, Decimal> =
    cw_storage_plus::Map::new("minted-dira");

// Collateral prices in dirham
pub const COLLATERAL_TOKEN_PRICE: cw_storage_plus::Item<Decimal> =
    cw_storage_plus::Item::new("collateral-price");

// Contract address of the cw20 Dira token
pub const CW20_DIRA_CONTRACT_ADDRESS: cw_storage_plus::Item<Addr> =
    cw_storage_plus::Item::new("cw20-dira-contract-address");
```

Contents of src/contract.rs:
```
use core::panic;

#[cfg(not(feature = "library"))]
use cosmwasm_std::entry_point;
use cosmwasm_std::{
    to_json_binary, Addr, BankMsg, Binary, Coin, Decimal, Deps, DepsMut, Env, MessageInfo,
    QueryRequest, Response, StdError, StdResult, Uint128, WasmQuery,
};

use cw2::set_contract_version;
use cw20::TokenInfoResponse;

use crate::error::ContractError;

use crate::msg::{
    AdminAddressesResponse, CW20DiraContractAddressResponse, CollateralPriceResponse,
    CollateralResponse, CollateralTokenDenomResponse, LiquidationHealthResponse,
    MintableHealthResponse, MintedDiraResponse, StablecoinHealthResponse,
};
use crate::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};

use crate::state::{
    ADMIN_ADDRESSES, COLLATERAL_TOKEN_DENOM, COLLATERAL_TOKEN_PRICE, CW20_DIRA_CONTRACT_ADDRESS,
    LIQUIDATION_HEALTH, LOCKED_COLLATERAL, MINTABLE_HEALTH, MINTED_DIRA,
};

// version info for migration info
const CONTRACT_NAME: &str = "crates.io:cosmwasm-stable-dira";
const CONTRACT_VERSION: &str = env!("CARGO_PKG_VERSION");

/****
 * THIS IS THE SECTION FOR MATCHING EXECUTE AND QUERY MESSAGES
 * FROM msg.rs IN HERE. THE ACTUAL FUNCTION IMPLEMENTATIONS ARE DONE IN THE SECTION
 * WAY BELOW THIS ONE
 ****/

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    info: MessageInfo,
    msg: InstantiateMsg,
) -> Result<Response, ContractError> {
    deps.api.debug("Instantiating contract...");
    deps.api.debug(&format!("Received message: {:?}", msg));

    if msg.liquidation_health.is_zero() || msg.mintable_health.is_zero() {
        return Err(ContractError::HealthCannotBeZero {});
    }

    if msg.collateral_token_denom.is_empty() {
        return Err(ContractError::MissingCollateralTokenDenom {});
    }

    if msg.mintable_health < msg.liquidation_health {
        return Err(ContractError::MintableHealthLowerThanLiquidationHealth {});
    }

    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;

    ADMIN_ADDRESSES.save(deps.storage, &vec![info.sender.clone()])?;
    LIQUIDATION_HEALTH.save(deps.storage, &msg.liquidation_health)?;
    MINTABLE_HEALTH.save(deps.storage, &msg.mintable_health)?;
    COLLATERAL_TOKEN_DENOM.save(deps.storage, &msg.collateral_token_denom)?;

    match msg.cw20_dira_contract_address {
        Some(contract_address) => {
            if helper_is_cw20_contract(deps.as_ref(), &contract_address) {
                CW20_DIRA_CONTRACT_ADDRESS.save(deps.storage, &contract_address)?;
            } else {
                return Err(ContractError::InvalidCW20ContractAddress {});
            }
        }
        _ => {}
    }

    Ok(Response::new()
        .add_attribute("method", "instantiate")
        .add_attribute("admin", info.sender))
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn execute(
    deps: DepsMut,
    _env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response, ContractError> {
    deps.api.debug("Executing function...");
    deps.api.debug(&format!("Received message: {:?}", &msg));

    match msg {
        ExecuteMsg::LockCollateral {} => execute_lock_collateral(deps, info),

        ExecuteMsg::UnlockCollateral {
            collateral_amount_to_unlock,
        } => execute_unlock_collateral(deps, info, collateral_amount_to_unlock),

        ExecuteMsg::MintDira { dira_to_mint } => execute_mint_dira(deps, info, dira_to_mint),
        ExecuteMsg::BurnDira { dira_to_burn } => execute_burn_dira(deps, info, dira_to_burn),

        ExecuteMsg::LiquidateStablecoins {
            wallet_address_to_liquidate,
        } => execute_liquidate_stablecoin_minter(deps, info, wallet_address_to_liquidate),

        ExecuteMsg::SetCollateralPriceInDirham {
            collateral_price_in_dirham,
        } => execute_set_collateral_price_in_dirham(deps, info, collateral_price_in_dirham),

        ExecuteMsg::SetLiquidationHealth { liquidation_health } => {
            execute_set_liquidation_health(deps, info, liquidation_health)
        }

        ExecuteMsg::SetMintableHealth { mintable_health } => {
            execute_set_mintable_health(deps, info, mintable_health)
        }

        ExecuteMsg::SetCW20DiraContractAddress {
            cw20_dira_contract_address,
        } => execute_set_cw20_dira_contact_address(deps, cw20_dira_contract_address),
    }
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::QueryLockedCollateral {
            wallet_address_to_query,
        } => query_locked_collateral(deps, wallet_address_to_query),
        QueryMsg::QueryMintedDira {
            wallet_address_to_query,
        } => query_minted_dira(deps, wallet_address_to_query),
        QueryMsg::QueryStablecoinHealth {
            stablecoin_minter_address_to_query,
        } => query_stablecoin_health(deps, stablecoin_minter_address_to_query),
        QueryMsg::QueryCollateralPrice {} => query_collateral_price(deps),
        QueryMsg::QueryLiquidationHealth {} => query_liquidation_health(deps),
        QueryMsg::QueryMintableHealth {} => query_mintable_health(deps),
        QueryMsg::QueryAdminAddresses {} => query_admin_addresses(deps),
        QueryMsg::QueryCollateralTokenDenom {} => query_collateral_token_denom(deps),
        QueryMsg::QueryCW20DiraContractAddress {} => query_cw20_dira_contract_address(deps),
    }
}

/****
 * THIS IS THE SECTION FOR ACTUAL IMPLEMENTATIONS OF ALL THE FUNCTIONS USED ABOVE!
 ****/

// Function to calculate stablecoin health of a particular user
// based on how much stablecoin they've minted and how much
// collateral they have locked
fn helper_calculate_stablecoin_health(
    minted_dira: Decimal,
    locked_collateral: Decimal,
    collateral_price_in_dirham: Decimal,
) -> Decimal {
    let locked_collateral_value_in_dirham = collateral_price_in_dirham * locked_collateral;

    if minted_dira.is_zero() {
        // if !locked_collateral_value_in_dirham.is_zero() {
        //     return Decimal::zero();
        // } else {
        return Decimal::MAX;
        // }
    }

    return locked_collateral_value_in_dirham / minted_dira;
}

// Function to calculate how much Dira the user can mint
// based on how much collateral is locked, what the
// value of the collateral is and what the
// mintable health is
fn helper_calculate_max_mintable_dira(
    locked_collateral: Decimal,
    collateral_price_in_dirham: Decimal,
    mintable_health: Decimal,
) -> Decimal {
    let max_mintable_dira = (locked_collateral * collateral_price_in_dirham) / mintable_health;

    max_mintable_dira
}

// Function to calculate how much collateral can be unlocked
// based on how much Dira the user has minted, what the value
// of the collateral is, and what the liquidation health is
fn helper_calculate_max_unlockable_collateral(
    locked_collateral: Decimal,
    collateral_price_in_dirham: Decimal,
    minted_dira: Decimal,
    mintable_health: Decimal,
) -> Decimal {
    let required_collateral_for_minted_dira =
        (minted_dira * mintable_health) / collateral_price_in_dirham;
    let unlockable_collateral = locked_collateral - required_collateral_for_minted_dira;

    unlockable_collateral
}

fn helper_is_cw20_contract(deps: Deps, contract_addr: &Addr) -> bool {
    let query_msg = to_json_binary(&cw20::Cw20QueryMsg::TokenInfo {}).unwrap();
    let query = QueryRequest::Wasm(WasmQuery::Smart {
        contract_addr: contract_addr.to_string(),
        msg: query_msg,
    });

    match deps.querier.query::<TokenInfoResponse>(&query) {
        Ok(_response) => true, // The contract supports CW20 TokenInfo query
        Err(_) => false,       // Not a CW20 contract
    }
}

// Function to lock collateral
fn execute_lock_collateral(deps: DepsMut, info: MessageInfo) -> Result<Response, ContractError> {
    let collateral_token_denom = COLLATERAL_TOKEN_DENOM
        .load(deps.storage)
        .map_err(|_| ContractError::MissingCollateralTokenDenom {})?;

    let message_sender = info.sender;

    // Check if the user has sent enough funds along with the transaction
    let sent_funds = info
        .funds
        .iter()
        .find(|coin| coin.denom == collateral_token_denom)
        .ok_or(ContractError::InsufficientFundsSent {})
        .unwrap();

    let sent_amount = Decimal::from_atomics(sent_funds.amount, 6).unwrap();

    match LOCKED_COLLATERAL.update(
        deps.storage,
        message_sender.clone(),
        |balance: Option<Decimal>| -> Result<Decimal, ContractError> {
            Ok(balance.unwrap_or_default() + sent_amount)
        },
    ) {
        Ok(_result) => {}
        Err(error) => {
            dbg!("Error in updating LOCKED_COLLATERAL storage item");
            return Err(error);
        }
    };

    // Send the lock collateral messages and return the Ok response
    Ok(Response::new()
        .add_attribute("action", "lock_collateral")
        .add_attribute("sender", message_sender.clone())
        .add_attribute(
            "total_funds_locked_by_user",
            LOCKED_COLLATERAL
                .load(deps.storage, message_sender)
                .unwrap_or_default()
                .to_string(),
        ))
}

// Function to unlock collateral
fn execute_unlock_collateral(
    deps: DepsMut,
    info: MessageInfo,
    collateral_amount: Decimal,
) -> Result<Response, ContractError> {
    let collateral_token_denom = COLLATERAL_TOKEN_DENOM
        .load(deps.storage)
        .map_err(|_| ContractError::MissingCollateralTokenDenom {})?;

    let message_sender = info.sender;

    let locked_collateral = LOCKED_COLLATERAL
        .load(deps.storage, message_sender.clone())
        .unwrap_or_default();

    let minted_dira = MINTED_DIRA
        .load(deps.storage, message_sender.clone())
        .unwrap_or_default();

    let mintable_health = MINTABLE_HEALTH.load(deps.storage)?;

    let collateral_price_in_dirham = COLLATERAL_TOKEN_PRICE
        .may_load(deps.storage)?
        .ok_or(ContractError::CollateralPriceNotSet {})
        .unwrap();

    let max_unlockable_collateral = helper_calculate_max_unlockable_collateral(
        locked_collateral,
        collateral_price_in_dirham,
        minted_dira,
        mintable_health,
    );

    if collateral_amount > max_unlockable_collateral {
        return Err(ContractError::UnlockAmountTooHigh {
            max_unlockable: max_unlockable_collateral,
        });
    }

    LOCKED_COLLATERAL.save(
        deps.storage,
        message_sender.clone(),
        &(locked_collateral - collateral_amount),
    )?;

    let return_collateral_to_user_message = BankMsg::Send {
        to_address: message_sender.to_string(),
        amount: vec![Coin {
            denom: collateral_token_denom,
            amount: collateral_amount.atomics() / Uint128::from(u128::pow(10, 12)),
        }],
    };

    Ok(Response::new()
        .add_message(return_collateral_to_user_message)
        .add_attribute("action", "unlock_collateral")
        .add_attribute("sender", message_sender.clone())
        .add_attribute(
            "total_funds_locked_by_user",
            LOCKED_COLLATERAL
                .load(deps.storage, message_sender)
                .unwrap_or_default()
                .to_string(),
        ))
}

// Function to mint dira
fn execute_mint_dira(
    deps: DepsMut,
    info: MessageInfo,
    dira_to_mint: Decimal,
) -> Result<Response, ContractError> {
    // First calculate how much dira this user can mint based on current collateral price
    // and how much collateral they have locked

    // To do this, first load all the variables from the blockchain
    let collateral_locked_by_user =
        match LOCKED_COLLATERAL.may_load(deps.storage, info.sender.clone()) {
            Ok(Some(locked_collateral)) => locked_collateral,
            _ => return Err(ContractError::InsufficientCollateral {}),
        };

    let previously_minted_dira = match MINTED_DIRA.may_load(deps.storage, info.sender.clone()) {
        Ok(Some(minted_dira)) => minted_dira,
        _ => Decimal::zero(),
    };

    let collateral_price_in_dirham = match COLLATERAL_TOKEN_PRICE.may_load(deps.storage) {
        Ok(Some(collateral_price)) => collateral_price,
        _ => return Err(ContractError::CollateralPriceNotSet {}),
    };

    let mintable_health = MINTABLE_HEALTH.load(deps.storage).unwrap();

    // Finally use the helper function to calculate max mintable dira by this user
    let max_mintable_dira = helper_calculate_max_mintable_dira(
        collateral_locked_by_user,
        collateral_price_in_dirham,
        mintable_health,
    );

    if dira_to_mint + previously_minted_dira > max_mintable_dira {
        return Err(ContractError::InsufficientCollateral {});
    }

    // Else, mint dira and transfer it to user, add that message to the response
    MINTED_DIRA.save(
        deps.storage,
        info.sender.clone(),
        &(dira_to_mint + previously_minted_dira),
    )?;

    // Get the CW20 contract address
    let cw20_dira_contract_address = match CW20_DIRA_CONTRACT_ADDRESS.may_load(deps.storage) {
        Ok(Some(contract_address)) => contract_address,
        _ => return Err(ContractError::CW20DiraContractAddressNotSet {}),
    };

    // Mint CW20 tokens
    let mint_msg = cw20::Cw20ExecuteMsg::Mint {
        recipient: info.sender.to_string(),
        amount: dira_to_mint.atomics() / Uint128::from(u128::pow(10, 12)),
    };

    let mint_cw20_message = cosmwasm_std::WasmMsg::Execute {
        contract_addr: cw20_dira_contract_address.to_string(),
        msg: to_json_binary(&mint_msg)?,
        funds: vec![],
    };

    Ok(Response::new()
        .add_message(mint_cw20_message)
        .add_attribute("action", "mint_dira")
        .add_attribute("sender", info.sender.to_string())
        .add_attribute(
            "total_dira_minted_by_sender",
            (dira_to_mint + previously_minted_dira).to_string(),
        ))
}

// Function to burn dira for the original collateral
fn execute_burn_dira(
    deps: DepsMut,
    info: MessageInfo,
    dira_to_return: Decimal,
) -> Result<Response, ContractError> {
    let previously_minted_dira = match MINTED_DIRA.may_load(deps.storage, info.sender.clone()) {
        Ok(Some(minted_dira)) => minted_dira,
        _ => Decimal::zero(),
    };

    if dira_to_return > previously_minted_dira {
        return Err(ContractError::ReturningMoreDiraThanMinted {});
    }

    MINTED_DIRA.save(
        deps.storage,
        info.sender.clone(),
        &(previously_minted_dira - dira_to_return),
    )?;

    // Get the CW20 contract address
    let cw20_dira_contract_address = match CW20_DIRA_CONTRACT_ADDRESS.may_load(deps.storage) {
        Ok(Some(contract_address)) => contract_address,
        _ => return Err(ContractError::CW20DiraContractAddressNotSet {}),
    };

    // Burn CW20 tokens
    let burn_msg = cw20::Cw20ExecuteMsg::BurnFrom {
        owner: info.sender.to_string(),
        amount: dira_to_return.atomics() / Uint128::from(u128::pow(10, 12)),
    };

    let burn_cw20_message = cosmwasm_std::WasmMsg::Execute {
        contract_addr: cw20_dira_contract_address.to_string(),
        msg: to_json_binary(&burn_msg)?,
        funds: vec![],
    };

    Ok(Response::new()
        .add_message(burn_cw20_message)
        .add_attribute("action", "burn_dira")
        .add_attribute("sender", info.sender.to_string())
        .add_attribute(
            "total_dira_remaining_by_sender",
            (previously_minted_dira - dira_to_return).to_string(),
        ))
}

// Function to liquidate stablecoins
fn execute_liquidate_stablecoin_minter(
    deps: DepsMut,
    info: MessageInfo,
    wallet_address_to_liquidate: Addr,
) -> Result<Response, ContractError> {
    // Validate the wallet address
    deps.api
        .addr_validate(wallet_address_to_liquidate.as_str())
        .map_err(|_| ContractError::InvalidWalletAddress {})?;

    // Load relevant data for liquidation
    let dira_minted_by_wallet_to_liquidate = MINTED_DIRA
        .load(deps.storage, wallet_address_to_liquidate.clone())
        .unwrap_or_default();

    let collateral_price_in_dirham = COLLATERAL_TOKEN_PRICE
        .load(deps.storage)
        .map_err(|_| ContractError::CollateralPriceNotSet {})?;

    let collateral_locked_by_user_to_liquidate = LOCKED_COLLATERAL
        .load(deps.storage, wallet_address_to_liquidate.clone())
        .unwrap_or_default();

    let liquidation_health = LIQUIDATION_HEALTH.load(deps.storage)?;

    // Calculate health
    let user_health = helper_calculate_stablecoin_health(
        dira_minted_by_wallet_to_liquidate,
        collateral_locked_by_user_to_liquidate,
        collateral_price_in_dirham,
    );

    // Check if the user is liquidatable
    if user_health >= liquidation_health {
        return Err(ContractError::TooHealthyToLiquidate {
            wallet_address: wallet_address_to_liquidate,
        });
    }

    // Liquidate: Reset the collateral to zero
    LOCKED_COLLATERAL.save(
        deps.storage,
        wallet_address_to_liquidate.clone(),
        &Decimal::zero(),
    )?;

    let mut liquidated_dira = Decimal::zero();
    MINTED_DIRA.update(
        deps.storage,
        wallet_address_to_liquidate.clone(),
        |minted_dira| {
            liquidated_dira = minted_dira.unwrap_or_default();
            Ok::<Decimal, StdError>(Decimal::zero())
        },
    )?;

    // Return a successful response
    Ok(Response::new()
        .add_attribute("action", "liquidate_stablecoins")
        .add_attribute("liquidated_wallet", wallet_address_to_liquidate.to_string())
        .add_attribute(
            "liquidated_collateral",
            collateral_locked_by_user_to_liquidate.to_string(),
        )
        .add_attribute("liquidated_dira", liquidated_dira.to_string())
        .add_attribute("initiator", info.sender.to_string())
        .add_attribute("liquidator_reward_paid", "0"))
    // TODO: Update liquidator reward logic here
}

// Function to set collateral prices in dirham
fn execute_set_collateral_price_in_dirham(
    deps: DepsMut,
    info: MessageInfo,
    collateral_price_in_dirham: Decimal,
) -> Result<Response, ContractError> {
    let admins = ADMIN_ADDRESSES.load(deps.storage)?;

    if !admins.contains(&info.sender) {
        return Err(ContractError::UnauthorizedUser {});
    }

    match COLLATERAL_TOKEN_PRICE.save(deps.storage, &collateral_price_in_dirham) {
        Ok(_result) => {}
        Err(error) => {
            dbg!(&error);
            panic!("Error in updating COLLATERAL_TOKEN_PRICE storage item");
        }
    }

    Ok(Response::new()
        .add_attribute("action", "set_collateral_price_in_dirham")
        .add_attribute("sender", info.sender)
        .add_attribute(
            "new_collateral_price",
            collateral_price_in_dirham.to_string(),
        ))
}

// Function to set liquidation health
fn execute_set_liquidation_health(
    deps: DepsMut,
    info: MessageInfo,
    liquidation_health: Decimal,
) -> Result<Response, ContractError> {
    let admins = ADMIN_ADDRESSES.load(deps.storage)?;

    if !admins.contains(&info.sender) {
        return Err(ContractError::UnauthorizedUser {});
    }

    LIQUIDATION_HEALTH.save(deps.storage, &liquidation_health)?;

    Ok(Response::new()
        .add_attribute("action", "set_liquidation_health")
        .add_attribute("sender", info.sender)
        .add_attribute("new_liquidation_health", liquidation_health.to_string()))
}

// Function to set mintable health
fn execute_set_mintable_health(
    deps: DepsMut,
    info: MessageInfo,
    mintable_health: Decimal,
) -> Result<Response, ContractError> {
    let admins = ADMIN_ADDRESSES.load(deps.storage)?;

    if !admins.contains(&info.sender) {
        return Err(ContractError::UnauthorizedUser {});
    }

    let current_liquidation_health = LIQUIDATION_HEALTH.load(deps.storage)?;

    MINTABLE_HEALTH.update(
        deps.storage,
        |_current_mintable_health| -> Result<Decimal, ContractError> {
            if mintable_health < current_liquidation_health {
                return Err(ContractError::MintableHealthLowerThanLiquidationHealth {});
            } else {
                return Ok(mintable_health);
            }
        },
    )?;

    Ok(Response::new()
        .add_attribute("action", "set_mintable_health")
        .add_attribute("sender", info.sender)
        .add_attribute("new_liquidation_health", mintable_health.to_string()))
}

fn execute_set_cw20_dira_contact_address(
    deps: DepsMut,
    cw20_dira_contract_address: Addr,
) -> Result<Response, ContractError> {
    if helper_is_cw20_contract(deps.as_ref(), &cw20_dira_contract_address) {
        CW20_DIRA_CONTRACT_ADDRESS.save(deps.storage, &cw20_dira_contract_address)?;
        return Ok(Response::new()
            .add_attribute("action", "set_cw20_dira_contract_address")
            .add_attribute("contract_address", cw20_dira_contract_address.into_string()));
    } else {
        return Err(ContractError::InvalidCW20ContractAddress {});
    }
}

/// Query the price of the collateral in dirham
fn query_collateral_price(deps: Deps) -> StdResult<Binary> {
    let collateral_price = COLLATERAL_TOKEN_PRICE
        .may_load(deps.storage)?
        .ok_or_else(|| StdError::not_found("collateral_price"))?;

    let response = CollateralPriceResponse { collateral_price };

    to_json_binary(&response)
}

/// Query the locked collateral of a given wallet address.
fn query_locked_collateral(deps: Deps, wallet_address_to_query: Addr) -> StdResult<Binary> {
    let locked_collateral = LOCKED_COLLATERAL
        .may_load(deps.storage, wallet_address_to_query.clone())?
        .unwrap_or_default();

    to_json_binary(&CollateralResponse {
        collateral_locked: locked_collateral,
    })
}

/// Query the amount of DIRA minted by a given wallet address.
fn query_minted_dira(deps: Deps, wallet_address_to_query: Addr) -> StdResult<Binary> {
    let dira_minted = MINTED_DIRA
        .may_load(deps.storage, wallet_address_to_query.clone())?
        .unwrap_or_default();

    to_json_binary(&MintedDiraResponse { dira_minted })
}

/// Query the stablecoin health of a specific minter.
fn query_stablecoin_health(
    deps: Deps,
    stablecoin_minter_address_to_query: Addr,
) -> StdResult<Binary> {
    let locked_collateral = LOCKED_COLLATERAL
        .may_load(deps.storage, stablecoin_minter_address_to_query.clone())?
        .unwrap_or_default();

    let minted_dira = MINTED_DIRA
        .may_load(deps.storage, stablecoin_minter_address_to_query.clone())?
        .unwrap_or_default();

    let collateral_price = COLLATERAL_TOKEN_PRICE.load(deps.storage)?;

    let health =
        helper_calculate_stablecoin_health(minted_dira, locked_collateral, collateral_price);

    to_json_binary(&StablecoinHealthResponse { health })
}

/// Query the current liquidation health threshold.
fn query_liquidation_health(deps: Deps) -> StdResult<Binary> {
    let liquidation_health = LIQUIDATION_HEALTH.load(deps.storage)?;

    to_json_binary(&LiquidationHealthResponse { liquidation_health })
}

/// Query the current mintable health threshold.
fn query_mintable_health(deps: Deps) -> StdResult<Binary> {
    let mintable_health = MINTABLE_HEALTH.load(deps.storage)?;

    to_json_binary(&MintableHealthResponse { mintable_health })
}

/// Query the list of admin addresses.
fn query_admin_addresses(deps: Deps) -> StdResult<Binary> {
    let admin_addresses = ADMIN_ADDRESSES.load(deps.storage)?;

    to_json_binary(&AdminAddressesResponse { admin_addresses })
}

/// Query the collateral token denom allowed by the contract.
fn query_collateral_token_denom(deps: Deps) -> StdResult<Binary> {
    let collateral_token_denom = COLLATERAL_TOKEN_DENOM.load(deps.storage)?;

    to_json_binary(&CollateralTokenDenomResponse {
        collateral_token_denom,
    })
}

/// Query the CW20 DIRA contract address set in the contract.
fn query_cw20_dira_contract_address(deps: Deps) -> StdResult<Binary> {
    let cw20_dira_contract_address = CW20_DIRA_CONTRACT_ADDRESS.may_load(deps.storage)?.clone();

    to_json_binary(&CW20DiraContractAddressResponse {
        cw20_dira_contract_address,
    })
}

```

Contents of src/msg.rs:
```
use cosmwasm_schema::QueryResponses;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use cosmwasm_std::{Addr, Decimal};

/// InstantiateMsg is used for initializing the contract.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct InstantiateMsg {
    pub liquidation_health: Decimal,
    pub mintable_health: Decimal,
    pub collateral_token_denom: String,
    pub cw20_dira_contract_address: Option<Addr>,
}

/// ExecuteMsg contains all the executable contract endpoints.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ExecuteMsg {
    // Lock and unlock collateral
    LockCollateral {},
    UnlockCollateral {
        collateral_amount_to_unlock: Decimal,
    },

    // Mint and burn DIRA stablecoin
    MintDira {
        dira_to_mint: Decimal,
    },
    BurnDira {
        dira_to_burn: Decimal,
    },

    // Liquidation
    LiquidateStablecoins {
        wallet_address_to_liquidate: Addr,
    },

    // Admin functionalities
    SetCollateralPriceInDirham {
        collateral_price_in_dirham: Decimal,
    },
    SetLiquidationHealth {
        liquidation_health: Decimal,
    },
    SetMintableHealth {
        mintable_health: Decimal,
    },
    SetCW20DiraContractAddress {
        cw20_dira_contract_address: Addr,
    },
}

/// QueryMsg contains all queryable contract endpoints.
/// These endpoints allow public access to the contract's state.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
#[derive(QueryResponses)]
pub enum QueryMsg {
    /// Query the total collateral locked by a specific wallet address.
    #[returns(CollateralResponse)]
    QueryLockedCollateral {
        wallet_address_to_query: Addr,
    },

    /// Query the total DIRA stablecoins minted by a specific wallet address.
    #[returns(MintedDiraResponse)]
    QueryMintedDira {
        wallet_address_to_query: Addr,
    },

    /// Query the current health of a stablecoin minter.
    #[returns[StablecoinHealthResponse]]
    QueryStablecoinHealth {
        stablecoin_minter_address_to_query: Addr,
    },

    /// Query the price of the collateral in dirham.
    #[returns(CollateralPriceResponse)]
    QueryCollateralPrice {},

    /// Query the liquidation health threshold.
    #[returns(LiquidationHealthResponse)]
    QueryLiquidationHealth {},

    /// Query the mintable health threshold.
    #[returns(MintableHealthResponse)]
    QueryMintableHealth {},

    /// Query the list of admin addresses.
    #[returns(AdminAddressesResponse)]
    QueryAdminAddresses {},

    /// Query the collateral token denom allowed.
    #[returns(CollateralTokenDenomResponse)]
    QueryCollateralTokenDenom {},

    /// Query the CW20 DIRA token contract address.
    #[returns(CW20DiraContractAddressResponse)]
    QueryCW20DiraContractAddress {},
}

/// Responses for each query

/// Response for querying locked collateral.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct CollateralResponse {
    pub collateral_locked: Decimal,
}

/// Response for querying minted DIRA.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct MintedDiraResponse {
    pub dira_minted: Decimal,
}

/// Response for querying stablecoin health.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct StablecoinHealthResponse {
    pub health: Decimal,
}

/// Response for querying the collateral price.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct CollateralPriceResponse {
    pub collateral_price: Decimal,
}

/// Response for querying the liquidation health threshold.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct LiquidationHealthResponse {
    pub liquidation_health: Decimal,
}

/// Response for querying the mintable health threshold.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct MintableHealthResponse {
    pub mintable_health: Decimal,
}

/// Response for querying the list of admin addresses.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct AdminAddressesResponse {
    pub admin_addresses: Vec<Addr>,
}

/// Response for querying the collateral token denom.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct CollateralTokenDenomResponse {
    pub collateral_token_denom: String,
}

/// Response for querying the CW20 DIRA contract address.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct CW20DiraContractAddressResponse {
    pub cw20_dira_contract_address: Option<Addr>,
}

```

